{"name": "Lean Topology game", "version": "1.1.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Lean Topology game-1.1.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 4, "objects": [{"type": "tactic", "content": "3", "name": "refl", "sideBar": true}, {"type": "text", "content": "4"}, {"type": "hint", "content": "5", "title": "6"}, {"type": "lean", "content": "7", "hidden": true}, {"type": "lemma", "text": "8", "lean": "lemma union_is_union (A B : set X) : A \u222a B = A \u222a B :=\n", "sideBar": false, "firstProofLineNumber": 43, "lastProofLineNumber": 44, "textBefore": "/- Tactic : refl\n\n## Summary\n\n`refl` is a tactic which proves goals of the form `X = X`.\n\n## Details\n\nThe `refl` tactic will close any goal of the form `A = B`\nwhere `A` and `B` are *exactly the same thing*.\n\n### Example:\nIf it looks like this in the top right hand box:\n```\nA B : set X\n\u22a2 A \u222a B = A \u222a B\n```\n\nthen\n\n`refl,`\n\nwill close the goal and solve the level. Don't forget the comma.\n\n-/\n\n/-\nWe will start by practising with the simplest tactic, namely *refl*. This just proves goals\nof the form $A = A$, no matter how complicated $A$ is. Let's see it in action!\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nJust delete `sorry` and type `refl,` (don't forget the comma!).\n-/\n\nvariables {X : Type} -- hide\n\n/- Lemma : no-side-bar\nIf A and B are sets, then A \u222a B = A \u222a B.\n-/\nlemma union_is_union (A B : set X) : A \u222a B = A \u222a B :=\nbegin\n", "proof": "  refl,\n  ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 2, "editorText": "sorry", "lineOffset": 42, "name": "union_is_union", "statement": "(A B : set X) : A \u222a B = A \u222a B"}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/set_theory_world/level01.lean"}, {"name": "", "problemIndex": 4, "objects": [{"type": "tactic", "content": "9", "name": "rw / rwa", "sideBar": true}, {"type": "text", "content": "10"}, {"type": "hint", "content": "11", "title": "12"}, {"type": "lean", "content": "13", "hidden": true}, {"type": "lemma", "text": "14", "lean": "lemma union_eq (A B C: set X) (h : A = B) : A \u222a C = B \u222a C :=\n", "sideBar": false, "firstProofLineNumber": 93, "lastProofLineNumber": 94, "textBefore": "/- Tactic : rw / rwa\n\n## Summary\n\nIf `h` is a proof of `X = Y`, then `rw h,` will change\nall `X`s in the goal to `Y`s. \n\n**Variants:** `rw \u2190 h` changes\n`Y` to `X` and\n`rw h at h2` changes `X` to `Y` in hypothesis `h2` instead\nof the goal.\n\n**Variant (rw and assumption):** If instead you use `rwa h` or `rwa \u2190 h`, Lean does performs\nthe `rw` and then looks whether\nthe goal is exactly one of your assumptions, in which case it closes it.\n\n## Details\n\nThe `rw` tactic is a way to do \"substituting in\". There\nare two distinct situations where use this tactics.\n\n1) If `h : A = B` is a hypothesis (i.e., a proof of `A = B`)\nin your local context (the box in the top right)\nand if your goal contains one or more `A`s, then `rw h`\nwill change them all to `B`'s. \n\n2) The `rw` tactic will also work with proofs of theorems\nwhich are equalities (look for them in the drop down\nmenu on the left, within Theorem Statements).\n\n**Important note:** if `h` is not a proof of the form `A = B`\nor `A \u2194 B` (for example if `h` is a function, an implication,\nor perhaps even a proposition itself rather than its proof),\nthen `rw` is not the tactic you want to use. For example,\n`rw (P = Q)` is never correct: `P = Q` is the true-false\nstatement itself, not the proof.\nIf `h : P = Q` is its proof, then `rw h` will work.\n\n**Pro tip 1:** If `h : A = B` and you want to change\n`B`s to `A`s instead, try `rw \u2190h` (get the arrow with `\\l`,\nnote that this is a small letter L, not a number 1).\n\n### Example:\nIf it looks like this in the top right hand box:\n```\nA B C : set X\nh : A = B \u222a C\n\u22a2 A \u222a B = B \u222a C\n```\n\nthen\n\n`rw h,`\n\nwill change the goal into `\u22a2 B \u222a C \u222a B = B \u222a C`.\n\n### Example: \nYou can use `rw` to change a hypothesis as well. \nFor example, if your local context looks like this:\n```\nA B C D : set X\nh1 : A = B \u2229 C\nh2 : B \u222a A = D\n\u22a2 D = B\n```\nthen `rw h1 at h2` will turn `h2` into `h2 : B \u222a B \u2229 C = D` (remember operator precedence).\n\n-/\n\n\n/-\nThe next tactic we will learn is *rw* (from rewrite). It rewrites equalities. That is,\nif we have a proof `h : A = B` and we want to prove `\u22a2 A \u2229 C = B \u2229 C`, then after `rw h` the goal\nwill become `\u22a2 A \u2229 C = A \u2229 C`, which seems reasonable.\n\nAfter many tactics (and `rw` is one of them) Lean tries to apply `refl`. This is why\nin the following proof you may get away with only one tactic application.\n\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nDelete `sorry` and type `rw h,` (don't forget the comma!). Lean tries `refl` afterwards,\nso you will see that this suffices.\n-/\n\nvariables {X : Type} -- hide\n\n/- Lemma : no-side-bar\nIf A, B and C are sets and A = B, then A \u222a C = B \u222a C.\n-/\nlemma union_eq (A B C: set X) (h : A = B) : A \u222a C = B \u222a C :=\nbegin\n", "proof": "  rw h,\n  ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 2, "editorText": "sorry", "lineOffset": 92, "name": "union_eq", "statement": "(A B C: set X) (h : A = B) : A \u222a C = B \u222a C"}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/set_theory_world/level02.lean"}, {"name": "", "problemIndex": 4, "objects": [{"type": "tactic", "content": "15", "name": "exact", "sideBar": true}, {"type": "text", "content": "16"}, {"type": "hint", "content": "17", "title": "18"}, {"type": "lean", "content": "19", "hidden": true}, {"type": "lemma", "text": "20", "lean": "lemma example_on_exact (A B : set X) (x : X) (h1 : x \u2208 A) (h2 : A = B) : x \u2208 B :=\n", "sideBar": false, "firstProofLineNumber": 48, "lastProofLineNumber": 50, "textBefore": "/- Tactic : exact\n\n## Summary \n\nIf the goal is `\u22a2 X` then `exact x` will close the goal if\nand only if `x` is a term of type `X`. \n\n## Details\n\nSay $P$, $Q$ and $R$ are types (i.e., what a mathematician\nmight think of as either sets or propositions),\nand the local context looks like this: \n\n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\n\nIf you can spot how to make a term of type `R`, then you\ncan just make it and say you're done using the `exact` tactic\ntogether with the formula you have spotted. For example the\nabove goal could be solved with\n\n`exact j(h(p)),`\n\nbecause $j(h(p))$ is easily checked to be a term of type $R$\n(i.e., an element of the set $R$, or a proof of the proposition $R$).\n\n-/\n\n/-\nIn this level we learn the tactic `exact`, which solves a goal that is exactly one of the hypotheses.\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nBy doing a `rw` you will get the goal to look exactly like one of the hypotheses...\n-/\n\nvariables {X : Type} -- hide\n\n/- Lemma : no-side-bar\nIf A and B are sets and x \u2208 A and A = B, then x \u2208 B.\n-/\nlemma example_on_exact (A B : set X) (x : X) (h1 : x \u2208 A) (h2 : A = B) : x \u2208 B :=\nbegin\n", "proof": "  rw \u2190 h2,\n  exact h1,\n  ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 3, "editorText": "sorry", "lineOffset": 47, "name": "example_on_exact", "statement": "(A B : set X) (x : X) (h1 : x \u2208 A) (h2 : A = B) : x \u2208 B"}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/set_theory_world/level03.lean"}, {"name": "", "problemIndex": 2, "objects": [{"type": "text", "content": "21"}, {"type": "lean", "content": "22", "hidden": true}, {"type": "lemma", "text": "23", "lean": "lemma example_on_rwa (A : set X) (x : X) (h1 : x \u2208 A) (h2 : A \u222a A = A) : x \u2208 A \u222a A :=\n", "sideBar": false, "firstProofLineNumber": 13, "lastProofLineNumber": 16, "textBefore": "/- \nTry to solve this level with exactly one line, using the `rwa` tactic.\n-/\n\n\nvariables {X : Type} -- hide\n\n/- Lemma : no-side-bar\nLet A be a set and x \u2208 A, using the assumption A \u222a A = A, we obtain that x \u2208 B.\n-/\nlemma example_on_rwa (A : set X) (x : X) (h1 : x \u2208 A) (h2 : A \u222a A = A) : x \u2208 A \u222a A :=\nbegin\n", "proof": "  rwa h2,\n  \n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 4, "editorText": "sorry", "lineOffset": 12, "name": "example_on_rwa", "statement": "(A : set X) (x : X) (h1 : x \u2208 A) (h2 : A \u222a A = A) : x \u2208 A \u222a A"}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/set_theory_world/level04.lean"}, {"name": "", "problemIndex": 4, "objects": [{"type": "tactic", "content": "24", "name": "intro", "sideBar": true}, {"type": "text", "content": "25"}, {"type": "hint", "content": "26", "title": "27"}, {"type": "lean", "content": "28", "hidden": true}, {"type": "lemma", "text": "29", "lean": "lemma example_on_intro (A B : set X) (x : X) (h : A = B) : x \u2208 A \u2192 x \u2208 B :=\n", "sideBar": false, "firstProofLineNumber": 54, "lastProofLineNumber": 58, "textBefore": "/- Tactic : intro\n\n## Summary:\n\n`intro p` will turn a goal `\u22a2 P \u2192 Q` into a hypothesis `p : P`\nand goal `\u22a2 Q`. If `P` and `Q` are sets `intro p` means \"let $p$ be an arbitrary element of $P$\".\nIf `P` and `Q` are propositions then `intro p` says \"assume $P$ is true\". \n\n## Details\n\nIf your goal is a function or an implication `\u22a2 P \u2192 Q` then `intro`\nwill always make progress. `intro p` turns\n\n`\u22a2 P \u2192 Q`\n\ninto \n\n```\np : P\n\u22a2 Q\n```\n\nThe opposite tactic to intro is `revert`; given the situation\njust above, `revert p` turns the goal back into `\u22a2 P \u2192 Q`.\n\n**Variant:** Instead of calling `intro` multiple times, you can use\n`intros`. That is, `intros h\u2081 h\u2082` is equivalent to `intro h\u2081, intro h\u2082`.\n\n## Example\n\nIf your goal is an implication $P\\implies Q$ then Lean writes\nthis as `\u22a2 P \u2192 Q`, and `intro p,` can be thought of as meaning\n\"let $p$ be a proof of $P$\", or more informally \"let's assume that\n$P$ is true\". The goal changes to `\u22a2 Q` and the hypothesis `p : P`\nappears in the local context.\n\n-/\n\n/-\nIn this level we introduce the tactic `intro`. You will need it to get started.\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nTry something like `intro h1,` and go from there.\n-/\n\nvariables {X : Type} -- hide\n\n/- Lemma : no-side-bar\nIf A, B and C are sets and A = B, then A \u222a C = B \u222a C.\n-/\nlemma example_on_intro (A B : set X) (x : X) (h : A = B) : x \u2208 A \u2192 x \u2208 B :=\nbegin\n", "proof": "  intro h1,\n  rw \u2190 h,\n  exact h1,\n  \n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 5, "editorText": "sorry", "lineOffset": 53, "name": "example_on_intro", "statement": "(A B : set X) (x : X) (h : A = B) : x \u2208 A \u2192 x \u2208 B"}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/set_theory_world/level05.lean"}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "30", "hidden": true}, {"type": "lean", "content": "31", "hidden": true}, {"type": "tactic", "content": "32", "name": "apply", "sideBar": true}, {"type": "text", "content": "33"}, {"type": "hint", "content": "34", "title": "35"}, {"type": "lean", "content": "36", "hidden": true}, {"type": "lemma", "text": "37", "lean": "lemma subset_transitive_basic (A B C : set X) (x : X) (hAB : x \u2208 A \u2192 x \u2208 B) (hBC : x \u2208 B \u2192 x \u2208 C) :\n  x \u2208 A \u2192 x \u2208 C :=\n", "sideBar": false, "firstProofLineNumber": 42, "lastProofLineNumber": 47, "textBefore": "import data.set.basic -- hide\nopen set -- hide\n/- Tactic : apply\n\n## Summary\n\nIf `h : P \u2192 Q` is a hypothesis, and the goal is `\u22a2 Q` then\n`apply h` changes the goal to `\u22a2 P`. \n\n## Details\n\nIf you have a function `h : P \u2192 Q` and your goal is `\u22a2 Q`\nthen `apply h` changes the goal to `\u22a2 P`. The logic is\nsimple: if you are trying to create a term of type `Q`,\nbut `h` is a function which turns terms of type `P` into\nterms of type `Q`, then it will suffice to construct a\nterm of type `P`. A mathematician might say: \"we need\nto construct an element of $Q$, but we have a function $h:P\\to Q$\nso it suffices to construct an element of $P$\". Or alternatively\n\"we need to prove $Q$, but we have a proof $h$ that $P\\implies Q$\nso it suffices to prove $P$\".\n\n-/\n\n/-\nIn this level we introduce the new tactic `apply`. Look at what it does and try to solve it!\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nStart with an `intro`, then try to `apply` the right hypothesis.\n-/\n\nvariables {X Y : Type} -- hide\n\n/- Lemma : no-side-bar\nIf A, B and C are sets and x \u2208 A, and we know that x \u2208 A \u2192 x \u2208 B and that x \u2208 B \u2192 x \u2208 C, then\nwe can deduce that x \u2208 C.\n-/\nlemma subset_transitive_basic (A B C : set X) (x : X) (hAB : x \u2208 A \u2192 x \u2208 B) (hBC : x \u2208 B \u2192 x \u2208 C) :\n  x \u2208 A \u2192 x \u2208 C :=\nbegin\n", "proof": "  intro h,\n  apply hBC,\n  apply hAB,\n  exact h,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 6, "editorText": "sorry", "lineOffset": 41, "name": "subset_transitive_basic", "statement": "(A B C : set X) (x : X) (hAB : x \u2208 A \u2192 x \u2208 B) (hBC : x \u2208 B \u2192 x \u2208 C) :\n  x \u2208 A \u2192 x \u2208 C"}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/set_theory_world/level06.lean"}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "38", "hidden": true}, {"type": "lean", "content": "39", "hidden": true}, {"type": "text", "content": "40"}, {"type": "hint", "content": "41", "title": "42"}, {"type": "lean", "content": "43", "hidden": true}, {"type": "lemma", "text": "44", "lean": "lemma subset_transitive (A B C : set X) (hAB : A \u2286 B) (hBC : B \u2286 C) :\n  A \u2286 C :=\n", "sideBar": false, "firstProofLineNumber": 28, "lastProofLineNumber": 34, "textBefore": "import data.set.basic -- hide\nopen set -- hide\n\n/-\nThere is an equivalence between set theory and logic, and Lean identifies these two.\n\nIn this equivalence, a logic statement P : X \u2192 true/false corresponds to the set\n$A = \\{ x : X | P(x) \\}$. Under this equivalence, logical implications P \u2192 Q translate into\nset inclusions A \u2286 B, and so on.\n\nThe goal of this lemma is to prove transitivity of set inclusion, giving almost the same\nproof as in the previous lemma.\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nStart with `intro x,`, then do exactly as in the previous level.\n-/\n\nvariables {X Y : Type} -- hide\n\n/- Lemma : no-side-bar\nIf A, B and C are sets and, and we know A \u2286 B and B \u2286 C, then\nwe have A \u2286 C.\n-/\nlemma subset_transitive (A B C : set X) (hAB : A \u2286 B) (hBC : B \u2286 C) :\n  A \u2286 C :=\nbegin\n", "proof": "  intro x,\n  intro hA,\n  apply hBC,\n  apply hAB,\n  exact hA,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 27, "name": "subset_transitive", "statement": "(A B C : set X) (hAB : A \u2286 B) (hBC : B \u2286 C) :\n  A \u2286 C"}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/set_theory_world/level07.lean"}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "45", "hidden": true}, {"type": "lean", "content": "46", "hidden": true}, {"type": "tactic", "content": "47", "name": "exfalso", "sideBar": true}, {"type": "hint", "content": "48", "title": "49"}, {"type": "lean", "content": "50", "hidden": true}, {"type": "lemma", "text": "51", "lean": "lemma one_eq_zero_of_contradiction (A : set X) (x : X) (h1 : x \u2208 A) (h2 : x \u2209 A): 1 = 0 :=\n", "sideBar": false, "firstProofLineNumber": 32, "lastProofLineNumber": 36, "textBefore": "import data.set.basic -- hide\nopen set -- hide\n\n/- Tactic : exfalso\n\n## Summary\n\nChanges the goal to `\u22a2 false`.\n\n## Details\n\nThis may seem hard to prove,\nbut it is useful when we have a contradiction in the hypotheses.\n\nFor example, if we have `h : \u00ac P` as a hypothesis and we apply `exfalso`\nwe can then `apply h` to transform the goal into `\u22a2 P`.\n-/\n\n\n/- Hint : Click here for a hint, in case you get stuck.\nIn Lean, the  negation `\u00ac P` of a statement is a shorthand for `P \u2192 false`. Therefore\nstart with `exfalso`, and remember that negation is the same as `\u2192 false`.\n-/\n\nvariables {X Y : Type} -- hide\n\n/- Lemma : no-side-bar\nWe can prove that 1 equals 0 if we have a contradiction in our hypotheses.\n-/\nlemma one_eq_zero_of_contradiction (A : set X) (x : X) (h1 : x \u2208 A) (h2 : x \u2209 A): 1 = 0 :=\nbegin\n", "proof": "  exfalso,\n  apply h2,\n  exact h1,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 5, "editorText": "sorry", "lineOffset": 31, "name": "one_eq_zero_of_contradiction", "statement": "(A : set X) (x : X) (h1 : x \u2208 A) (h2 : x \u2209 A): 1 = 0"}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/set_theory_world/level08.lean"}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "52", "hidden": true}, {"type": "lean", "content": "53", "hidden": true}, {"type": "lean", "content": "54", "hidden": true}, {"type": "lean", "content": "55", "hidden": true}, {"type": "tactic", "content": "56", "name": "split", "sideBar": true}, {"type": "text", "content": "57"}, {"type": "lemma", "text": "58", "lean": "lemma mem_prod_iff {p : X \u00d7 Y} (A: set X) (B : set Y): p \u2208 A \u00d7\u02e2 B \u2194 p.1 \u2208 A \u2227 p.2 \u2208 B :=\n", "sideBar": false, "firstProofLineNumber": 64, "lastProofLineNumber": 69, "textBefore": "import data.set.basic -- hide\nimport data.set.prod --hide\nopen set -- hide\n\nvariables {X Y : Type} -- hide\n\n/- Tactic : split\n\n## Summary:\n\nIf the goal is `P \u2227 Q` or `P \u2194 Q` then `split` will break it into two goals.\n\n## Details\n\nIf `P Q : Prop` and the goal is `\u22a2 P \u2227 Q`, then `split` will change it into\ntwo goals, namely `\u22a2 P` and `\u22a2 Q`. \n\nIf `P Q : Prop` and the goal is `\u22a2 P \u2194 Q`, then `split` will change it into\ntwo goals, namely `\u22a2 P \u2192 Q` and `\u22a2 Q \u2192 P`.  \n\n## Example:\n\nIf your local context (the top right window) looks like this\n```\nX : Type\nA B : set X\nx : X\n\u22a2 x \u2208 A \u2194 x \u2208 B\n```\n\nthen after\n\n`split,`\n\nit will look like this:\n\n```\n2 goals\nX : Type\nA B : set X\nx : X\n\u22a2 x \u2208 A \u2192 x \u2208 B\n\n\nX : Type\nA B : set X\nx : X\n\u22a2 x \u2208 B \u2192 x \u2208 A\n```\n-/\n\n/-\nIn this level we will learn the `split` tactic. It breaks a goal `P \u2227 Q` into two goals (proving `P`, and then proving `Q`),\nand also breaks goals of the form `P \u2194 Q` into proving each of the implications separately.\n\nYou will need to use both features to accomplish this proof.\n-/\n/- Lemma : no-side-bar\nGiving an element `p` of a product type `X \u00d7 Y` and two subsets `A \u2286 X` `B \u2286 Y`. The element \n`p` is the set `A \u00d7 B` (as sets) if only if the first component of `p` is in `A` and the second in `B`.\n-/\nlemma mem_prod_iff {p : X \u00d7 Y} (A: set X) (B : set Y): p \u2208 A \u00d7\u02e2 B \u2194 p.1 \u2208 A \u2227 p.2 \u2208 B :=\nbegin\n", "proof": "  split;\n  intro h;\n  exact \u27e8h.1, h.2\u27e9\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 6, "editorText": "sorry", "lineOffset": 63, "name": "mem_prod_iff", "statement": "{p : X \u00d7 Y} (A: set X) (B : set Y): p \u2208 A \u00d7\u02e2 B \u2194 p.1 \u2208 A \u2227 p.2 \u2208 B"}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/set_theory_world/level09.lean"}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "59", "hidden": true}, {"type": "lean", "content": "60", "hidden": true}, {"type": "tactic", "content": "61", "name": "ext", "sideBar": true}, {"type": "tactic", "content": "62", "name": "left and right", "sideBar": true}, {"type": "tactic", "content": "63", "name": "cases", "sideBar": true}, {"type": "text", "content": "64"}, {"type": "lean", "content": "65", "hidden": true}, {"type": "lemma", "text": "66", "lean": "lemma inter_union (A B C : set X) : A \u2229 (B \u222a C) = (A \u2229 B) \u222a (A \u2229 C) :=\n", "sideBar": true, "firstProofLineNumber": 117, "lastProofLineNumber": 157, "textBefore": "import data.set.basic -- hide\nopen set -- hide\n\n/- Tactic : ext\n\n## Summary\n\nIf `A` and `B` are sets and the goal is `A = B`, then\nusing the `ext` tactic will change it to `x \u2208 A \u2194 x \u2208 B`.\n\nVariant: `ext y` will change the goal to `y \u2208 A \u2194 y \u2208 B`.\n\n## Details\n\nThis tactic applies the \"extensionality\" axiom of set theory,\nwhich says that two sets are equal iff for all `x`, `x` belongs\nto the first iff `x` belongs to the second.\n\n### Example:\nIf it looks like this in the top right hand box:\n```\nA B : set X\n\u22a2 A = B\n```\n\nthen\n\n`ext,`\n\nwill change the goal into\n```\nA B : set X\nx : X\n\u22a2 x \u2208 A \u2194 x \u2208 B\n```\n-/\n\n\n/- Tactic : left and right\n\n## Summary\n\n`left` and `right` work on the goal, and they change\n`\u22a2 P \u2228 Q` to `\u22a2 P` and `\u22a2 Q` respectively.\n\n## Details\n\nThe tactics `left` and `right` work on a goal which is a type with\ntwo constructors, the classic example being `P \u2228 Q`. \nTo prove `P \u2228 Q` it suffices to either prove `P` or prove `Q`,\nand once you know which one you are going for you can change\nthe goal with `left` or `right` to the appropriate choice.\n-/\n\n/- Tactic : cases\n\n## Summary:\n\n`cases` is a tactic which works on hypotheses.\nIf `h : P \u2227 Q` or `h : P \u2194 Q` is a hypothesis then `cases h with h1 h2` will remove `h`\nfrom the list of hypotheses and replace it with the \"ingredients\" of `h`,\ni.e. `h1 : P` and `h2 : Q`, or `h1 : P \u2192 Q` and `h2 : Q \u2192 P`. Also\nworks with `h : P \u2228 Q` and `n : mynat`. \n\n## Details\n\nHow does one prove `P \u2227 Q`? The way to do it is to prove `P` and to\nprove `Q`. There are hence two ingredients which go into a proof of\n`P \u2227 Q`, and the `cases` tactic extracts them. \n\nMore precisely, if the local context contains\n```\nh : P \u2227 Q`\n```\n\nthen after the tactic `cases h with p q,` the local context will\nchange to\n```\np : P,\nq : Q\n```\nand `h` will disappear. \n\nSimilarly `h : P \u2194 Q` is proved by proving `P \u2192 Q` and `Q \u2192 P`,\nand `cases h with hpq hqp` will delete our assumption `h` and\nreplace it with\n```\nhpq : P \u2192 Q,\nhqp : Q \u2192 P\n```\n\nBe warned though -- `rw h` works with `h : P \u2194 Q` (`rw` works with\n`=` and `\u2194`), whereas you cannot rewrite with an implication.\n\n`cases` also works with hypotheses of the form `P \u2228 Q`. Here the situation\nis different however. \nTo prove `P \u2228 Q` you need to give either a proof of `P` *or* a proof\nof `Q`, so if `h : P \u2228 Q` then `cases h with p q` will change one goal\ninto two, one with `p : P` and the other with `q : Q`.\n-/\n\n\n/-\nThe following lemma can be proved using `ext`, `split`, `cases`, `left`, `right` tactics. Learn what\nthey do in the side-bar, and use them to clear this goal.\n\nIf you are lazy, the `finish` tactic will take the fun out of this exercise. So try to not use it.\n-/\n\nvariables {X Y : Type} -- hide\n\n/- Lemma :\nThe distributive property of \u2229 with respect to \u222a.\n-/\nlemma inter_union (A B C : set X) : A \u2229 (B \u222a C) = (A \u2229 B) \u222a (A \u2229 C) :=\nbegin\n", "proof": "  ext,\n  split,\n  {\n    intro h,\n    cases h,\n    cases h_right,\n    {\n      left,\n      split;\n      assumption,\n    },\n    {\n      right,\n      split;\n      assumption,\n    }\n  },\n  {\n    intro h,\n    cases h,\n    {\n      split,\n      {\n        exact h.1,\n      },\n      {\n        left,\n        exact h.2,\n      },\n    },\n    {\n      split,\n      {\n        exact h.1,\n      },\n      {\n        right,\n        exact h.2,\n      }\n    }\n  }", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 41, "editorText": "sorry", "lineOffset": 116, "name": "inter_union", "statement": "(A B C : set X) : A \u2229 (B \u222a C) = (A \u2229 B) \u222a (A \u2229 C)"}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/set_theory_world/level10.lean"}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "67", "hidden": true}, {"type": "lean", "content": "68", "hidden": true}, {"type": "lean", "content": "69", "hidden": true}, {"type": "axiom", "content": "70", "name": "finite.induction_on", "sideBar": true}, {"type": "axiom", "content": "71", "name": "mem_insert_iff", "sideBar": true}, {"type": "axiom", "content": "72", "name": "sInter_empty", "sideBar": true}, {"type": "axiom", "content": "73", "name": "sInter_insert", "sideBar": true}, {"type": "text", "content": "74"}, {"type": "lean", "content": "75", "hidden": true}, {"type": "lemma", "text": "76", "lean": "lemma sInter_of_inter {S : set (set X)} {P : set X \u2192 Prop} (hfin : finite S) (huniv : P univ) (hinter : \u2200 A B : set X, P A \u2192 P B \u2192 P (A \u2229 B))\n : (\u2200 s \u2208 S, P s) \u2192 P ( sInter S ) :=\n", "sideBar": true, "firstProofLineNumber": 59, "lastProofLineNumber": 86, "textBefore": "import data.set.basic -- hide\nimport data.set.finite -- hide\nopen set -- hide\n\n/- Axiom : finite.induction_on\n\nIf P is a property of sets, to prove that P(s) is true for all *finite* sets s\nit is enough to prove it for the empty set (h\u2080) and to prove\n(h\u2081) that if s is a finite set and a \u2209 s then P(s) \u2192  P({a} \u222a s).\n\nfinite.induction_on {P : set \u03b1 \u2192 Prop} {s : set \u03b1} (h : finite s)\n  (h\u2080 : P \u2205) (h\u2081 : \u2200 {a s}, a \u2209 s \u2192 finite s \u2192 P s \u2192 P (insert a s)) : P s\n-/\n\n/- Axiom : mem_insert_iff\n\nWe have x \u2208 {a} \u222a s if and only if x = a or x \u2208 s.\n\nmem_insert_iff {x a : \u03b1} {s : set \u03b1} : x \u2208 insert a s \u2194 x = a \u2228 x \u2208 s\n-/\n\n/- Axiom : sInter_empty\n\nThe empty intersection is everything.\n\nsInter_empty : \u22c2\u2080 \u2205 = univ\n-/\n\n\n/- Axiom : sInter_insert\nIf T is a set of sets, and s is a set, the set-wise intersection \u22c2\u2080 (s \u222a T) equals s \u2229 \u22c2\u2080 T.\n\nsInter_insert (s : set \u03b1) (T : set (set \u03b1)) : \u22c2\u2080 (insert s T) = s \u2229 \u22c2\u2080 T\n\n-/\n\n\n/-\nThis is the final level, and be advised that it is *much* harder than the previous ones.\n\nWe will use the following lemma when we start proving facts about topological spaces.\n\nIt seems clear that we want to use induction, so try to apply the `finite.induction_on`\nlemma.\n\nFor the base case you will need `sInter_empty`, while for inductive step the lemmas `sInter_insert`, `mem_insert_iff` may be useful. Check the sidebar for their meaning.\n-/\n\n\nvariables {X Y : Type} -- hide\n\n/- Lemma :\nIf P is a property of sets which is closed under pairwise intersection then it is also closed under\narbitrary finite intersections.\n-/\nlemma sInter_of_inter {S : set (set X)} {P : set X \u2192 Prop} (hfin : finite S) (huniv : P univ) (hinter : \u2200 A B : set X, P A \u2192 P B \u2192 P (A \u2229 B))\n : (\u2200 s \u2208 S, P s) \u2192 P ( sInter S ) :=\nbegin\n", "proof": "  apply finite.induction_on hfin,\n  {\n    intro h,\n    rwa sInter_empty,\n  },\n  {\n    intros U S hUS hSfin hind h,\n    rw sInter_insert,\n    apply hinter,\n    {\n      apply h,\n      rw mem_insert_iff,\n      left, refl,\n    },\n    {\n      apply hind,\n      intros s hs,\n      apply h,\n      rw mem_insert_iff,\n      right,\n      exact hs,\n    }\n  },\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 28, "editorText": "sorry", "lineOffset": 58, "name": "sInter_of_inter", "statement": "{S : set (set X)} {P : set X \u2192 Prop} (hfin : finite S) (huniv : P univ) (hinter : \u2200 A B : set X, P A \u2192 P B \u2192 P (A \u2229 B))\n : (\u2200 s \u2208 S, P s) \u2192 P ( sInter S )"}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/set_theory_world/level11.lean"}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "77", "hidden": true}, {"type": "lean", "content": "78", "hidden": true}, {"type": "lean", "content": "79", "hidden": true}, {"type": "tactic", "content": "80", "name": "use", "sideBar": true}, {"type": "lemma", "text": "81", "lean": "lemma example_on_use (\u03b1 : Type) (A : set \u03b1) (B : set \u03b1) : \u2203 S : set \u03b1, S \u2286 A \u2229 B :=\n", "sideBar": true, "firstProofLineNumber": 17, "lastProofLineNumber": 25, "textBefore": "import data.set.basic -- hide\nimport data.set.finite -- hide\nopen set -- hide\n\n/- Tactic : use\n\n## Summary\nThe tactic use specializes the goal with a particular case. For example, if we want to prove the statement \"there exists a natural number which is odd\", we will need to provide a concrete number like 3. \n\n-/\n\n/- Lemma :\nIf A and B are subsets of a fixed set, then there exists a subset S such that S \u2286 A \u2229 B.\n-/\nlemma example_on_use (\u03b1 : Type) (A : set \u03b1) (B : set \u03b1) : \u2203 S : set \u03b1, S \u2286 A \u2229 B :=\nbegin\n", "proof": "  use \u2205,\n  intros h h1,\n  split,\n  repeat\n  {\n    exfalso,\n    exact h1\n  }\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 9, "editorText": "sorry", "lineOffset": 16, "name": "example_on_use", "statement": "(\u03b1 : Type) (A : set \u03b1) (B : set \u03b1) : \u2203 S : set \u03b1, S \u2286 A \u2229 B"}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/set_theory_world/level12.lean"}]}, {"name": "82", "levels": [{"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "83", "hidden": true}, {"type": "lean", "content": "84", "hidden": true}, {"type": "text", "content": "85"}, {"type": "lean", "content": "86", "hidden": true}, {"type": "lean", "content": "87", "hidden": true}, {"type": "lemma", "text": "88", "lean": "lemma image_union (f : X \u2192 Y) (A B : set X) : f '' (A \u222a B) = f '' A \u222a f '' B :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 62, "textBefore": "import data.set.basic -- hide\nimport tactic -- hide\n\n/-\n# Level 1: The image of a union\n\nIn this level we prove that the image of a union of two sets if the union of their images.\n-/\n\nopen set -- hide\nvariables{X Y: Type} -- hide\n\n/- Lemma\n$ f(A \u222a B) = f(A) \u222a f(B) $\n-/\nlemma image_union (f : X \u2192 Y) (A B : set X) : f '' (A \u222a B) = f '' A \u222a f '' B :=\nbegin\n", "proof": "  ext y,\n  split,\n  {\n    intro h1,\n    cases h1,\n    cases h1_h,\n    cases h1_h_left,\n    {\n      left, \n      rw <-h1_h_right,\n      use [h1_w, h1_h_left],\n    },\n    {right,\n    rw <-h1_h_right,\n    use [h1_w, h1_h_left],\n    },\n\n  },\n  {\n    intro h1,\n    cases h1,\n    {\n      cases h1,\n      cases h1_h,\n      rw <-h1_h_right,\n      have h : h1_w \u2208 A \u222a B,\n      {\n        left,\n        exact h1_h_left,\n      },\n      use [h1_w, h],\n    },\n    {\n      cases h1,\n      cases h1_h,\n      rw <-h1_h_right,\n      have h : h1_w \u2208 A \u222a B,\n      {\n        right,\n        exact h1_h_left,\n      },\n      use [h1_w, h],\n    },\n  },\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 45, "editorText": "sorry", "lineOffset": 17, "name": "image_union", "statement": "(f : X \u2192 Y) (A B : set X) : f '' (A \u222a B) = f '' A \u222a f '' B"}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/function_world/level1.lean"}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "89", "hidden": true}, {"type": "lean", "content": "90", "hidden": true}, {"type": "lean", "content": "91", "hidden": true}, {"type": "lean", "content": "92", "hidden": true}, {"type": "lean", "content": "93", "hidden": true}, {"type": "text", "content": "94"}, {"type": "lemma", "text": "95", "lean": "lemma image_Union (f: X \u2192 Y) ( A : I \u2192 set X) : f '' ( \u22c3 i, A i ) = \u22c3 i, f '' A i :=\n", "sideBar": true, "firstProofLineNumber": 20, "lastProofLineNumber": 53, "textBefore": "import data.set.basic -- hide\nimport tactic -- hide\nopen set -- hide\n\nopen set function -- hide\n\nvariables {X Y I: Type} -- hide\n/-\n# Level 1: The image of an indexed union\n\nThis level is similar to the previous one. You can use a similar strategy.\n\n-/\n\n/- Lemma\nIf f is a function and A\u1d62 are sets, then f(\u22c3 A\u1d62) = \u22c3 f(A\u1d62)\n-/\nlemma image_Union (f: X \u2192 Y) ( A : I \u2192 set X) : f '' ( \u22c3 i, A i ) = \u22c3 i, f '' A i :=\nbegin \n", "proof": "  ext y,\n  split,\n  {\n    intro h1,\n    cases h1 with x hx, -- millor donar noms, per facilitar l'argument\n    cases hx with hx1 hx2, -- no tenia bons noms, per\u00f2 almenys s\u00f3n m\u00e9s curts\n    simp,\n    rw \u2190 hx2, --aqu\u00ed voldria combinar dues hipotesis per obtenir el goal\n    cases hx1 with U hU,\n    simp at hU,\n    cases hU with hU1 hU2,\n    cases hU1 with i hi,\n    -- Ara hem de fer servir les hip\u00f2tesis que tenim...\n    use i, -- l'index que busquem l'acabem d'obtenir al pas anterior\n    use x,\n    rw hi,\n    exact \u27e8hU2, rfl\u27e9,\n  },\n  {\n    intro h1,\n    simp at h1,\n    cases h1 with i hx,\n    simp,\n    cases hx with x hx2,\n    cases hx2 with hxA hxy,\n    use x,\n    use i, \n  {\n    exact hxA,\n  },\n  {\n    exact hxy,\n  },\n  },", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 34, "editorText": "sorry", "lineOffset": 19, "name": "image_Union", "statement": "(f: X \u2192 Y) ( A : I \u2192 set X) : f '' ( \u22c3 i, A i ) = \u22c3 i, f '' A i"}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/function_world/level2.lean"}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "96", "hidden": true}, {"type": "lean", "content": "97", "hidden": true}, {"type": "lean", "content": "98", "hidden": true}, {"type": "lean", "content": "99", "hidden": true}, {"type": "lean", "content": "100", "hidden": true}, {"type": "axiom", "content": "101", "name": "", "sideBar": true}, {"type": "axiom", "content": "102", "name": "", "sideBar": true}, {"type": "text", "content": "103"}, {"type": "lemma", "text": "104", "lean": "lemma preimage_intersection_is_intersection (f: X \u2192 Y) ( A: I \u2192 set Y) : f \u207b\u00b9'(\u22c2 i, A i)=\u22c2 i, f \u207b\u00b9'  A i :=\n", "sideBar": false, "firstProofLineNumber": 32, "lastProofLineNumber": 57, "textBefore": "import data.set.basic -- hide\nimport tactic -- hide\nopen set -- hide\n\nopen set function -- hide\n\nvariables {X Y I: Type} -- hide\n\n/- Axiom :\nmem_preimage : (a \u2208 f \u207b\u00b9' s) \u2194 (f a \u2208 s)\n-/\n\n/- Axiom :\nmem_Inter : x \u2208 (\u22c2 i, s i) \u2194 \u2200 i, x \u2208 s i\n-/\n\n/-\n\n# Level 3: The preimage of an intersection\n\nTo complete this level you will need to use the `mem_preimage` and `mem_Inter`\ntheorems, which you can find in the side bar.\n\n-/\n\n\n/- Lemma : no-side-bar\nIf f is a function and A_i are sets, then f\u207b\u00b9(\u22c2 A_i)=\u22c2 f\u207b\u00b9(A_i)\n-/\nlemma preimage_intersection_is_intersection (f: X \u2192 Y) ( A: I \u2192 set Y) : f \u207b\u00b9'(\u22c2 i, A i)=\u22c2 i, f \u207b\u00b9'  A i :=\nbegin \n", "proof": "ext y,\nsplit,\n{\n  intro h,\n  rw mem_preimage at h,\n  rw mem_Inter at h \u22a2,\n  intro i,\n  rw mem_preimage,\n  exact h i,\n\n\n\n},\n{\n  intro h,\n  rw mem_Inter at h,\n  rw mem_preimage,\n  rw mem_Inter,\n  intro i,\n  rw \u2190 mem_preimage,\n  exact h i,\n\n\n  \n},\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 26, "editorText": "sorry", "lineOffset": 31, "name": "preimage_intersection_is_intersection", "statement": "(f: X \u2192 Y) ( A: I \u2192 set Y) : f \u207b\u00b9'(\u22c2 i, A i)=\u22c2 i, f \u207b\u00b9'  A i"}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/function_world/level3.lean"}], "parents": [0]}, {"name": "105", "levels": [{"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "106", "hidden": true}, {"type": "axiom", "content": "107", "name": "The total set (called `univ`) is open.", "sideBar": true}, {"type": "axiom", "content": "108", "name": "The intersection of two open sets is open.", "sideBar": true}, {"type": "axiom", "content": "109", "name": "The union of an arbitrary set of open sets is open.", "sideBar": true}, {"type": "axiom", "content": "110", "name": "The union over the empty set is empty.", "sideBar": true}, {"type": "text", "content": "111"}, {"type": "lean", "content": "112", "hidden": true}, {"type": "lean", "content": "113", "hidden": true}, {"type": "text", "content": "114"}, {"type": "lean", "content": "115", "hidden": true}, {"type": "hint", "content": "116", "title": "117"}, {"type": "lemma", "text": "118", "lean": "lemma is_open_empty {X : Type} [topological_space X] : is_open (\u2205 : set X) :=\n", "sideBar": true, "firstProofLineNumber": 43, "lastProofLineNumber": 50, "textBefore": "import basic_defs_world.definition -- hide\n\n/- Axiom : The total set (called `univ`) is open.\nuniv_mem : is_open set.univ\n-/\n\n/- Axiom : The intersection of two open sets is open.\ninter : \u2200 (U V : set X) (hA : is_open U) (hB : is_open V), is_open (U \u2229 V)\n-/\n\n/- Axiom : The union of an arbitrary set of open sets is open.\nunion : \u2200 (Y : set (set X)) (h : \u2200 U \u2208 Y, is_open U), is_open (\u22c3\u2080 Y)\n-/\n\n/- Axiom : The union over the empty set is empty.\nsUnion_empty : \u22c3\u2080 \u2205 = \u2205\n-/\n\n/-\n# Level 1 : The empty set is open.\n-/\nnoncomputable theory -- hide\nopen set -- hide\n\n/-\nIn many textbooks, one of the axioms of a topological space is that the empty set is open. This actually follows from the other axioms!\n-/\n\nnamespace topological_space -- hide\n\n\n/- Hint : Click here for a hint, in case you get stuck.\nIn Lean, sets are notation for logical statements. That is, the set\n`a \u2208 { x : X | P x }` means *the same as* `P a`. As a somewhat degenerate\nexample, `a \u2208 \u2205` means `false`.\n-/\n\n/- Lemma\nProve that the empty set is open.\n-/\nlemma is_open_empty {X : Type} [topological_space X] : is_open (\u2205 : set X) :=\nbegin\n", "proof": "  rw \u2190sUnion_empty,\n  apply union,\n  tauto,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend topological_space -- hide\n", "height": 8, "editorText": "sorry", "lineOffset": 42, "name": "is_open_empty", "statement": "{X : Type} [topological_space X] : is_open (\u2205 : set X)"}, {"type": "lean", "content": "119", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/basic_defs_world/level1.lean"}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "120", "hidden": true}, {"type": "lean", "content": "121", "hidden": true}, {"type": "lean", "content": "122", "hidden": true}, {"type": "text", "content": "123"}, {"type": "lemma", "text": "124", "lean": "lemma open_of_union {X : Type} [topological_space X] {U V : set X}\n(hU : is_open U) (hV : is_open V): is_open (U \u222a V) :=\n", "sideBar": true, "firstProofLineNumber": 16, "lastProofLineNumber": 26, "textBefore": "import basic_defs_world.level1 --hide\nopen set --hide\nnamespace topological_space --hide\n\n\n/-\n# Level 2: Union of two open sets\n-/\n\n/- Lemma\nThe union of two open sets is open.\n-/\nlemma open_of_union {X : Type} [topological_space X] {U V : set X}\n(hU : is_open U) (hV : is_open V): is_open (U \u222a V) :=\nbegin\n", "proof": "  let I : set (set X) := {U, V},\n  have H : \u22c3\u2080 I = U \u222a V := sUnion_pair U V,\n  rw \u2190H,\n  apply union,\n  intros B hB,\n  replace hB : B = U \u2228 B = V, by tauto,\n  cases hB; {rw hB, assumption},\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend topological_space --hide\n", "height": 11, "editorText": "sorry", "lineOffset": 15, "name": "open_of_union", "statement": "{X : Type} [topological_space X] {U V : set X}\n(hU : is_open U) (hV : is_open V): is_open (U \u222a V)"}, {"type": "lean", "content": "125", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/basic_defs_world/level2.lean"}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "126", "hidden": true}, {"type": "lean", "content": "127", "hidden": true}, {"type": "lean", "content": "128", "hidden": true}, {"type": "lean", "content": "129", "hidden": true}, {"type": "text", "content": "130"}, {"type": "hint", "content": "131", "title": "132"}, {"type": "lemma", "text": "133", "lean": "lemma is_open_sInter {X : Type} [topological_space X] {S : set (set X)}\n(hfin : finite S) (h : \u2200 s \u2208 S, is_open s): is_open (sInter S) :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 39, "textBefore": "import basic_defs_world.level2 --hide\nimport set_theory_world.level11 --hide\nopen set --hide\nnamespace topological_space --hide\n\n\n/-\n# Level 3: Intersection of a finite set of open sets is open.\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nThe `sInter_of_inter` lemma will be of great help here.\n-/\n\n/- Lemma\nThe intersection of a finite set of open sets is open.\n-/\nlemma is_open_sInter {X : Type} [topological_space X] {S : set (set X)}\n(hfin : finite S) (h : \u2200 s \u2208 S, is_open s): is_open (sInter S) :=\nbegin\n", "proof": "  apply sInter_of_inter,\n  {\n    exact hfin,\n  },\n  {\n    exact univ_mem,\n  },\n  {\n    intros A B hA hB,\n    exact inter hA hB,\n  },\n  {\n    exact h,\n  }\n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend topological_space --hide\n", "height": 19, "editorText": "sorry", "lineOffset": 20, "name": "is_open_sInter", "statement": "{X : Type} [topological_space X] {S : set (set X)}\n(hfin : finite S) (h : \u2200 s \u2208 S, is_open s): is_open (sInter S)"}, {"type": "lean", "content": "134", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/basic_defs_world/level3.lean"}], "parents": [1]}, {"name": "135", "levels": [{"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "136", "hidden": true}, {"type": "axiom", "content": "137", "name": "A set A is the neighborhood of a point x if there is an open U such that x \u2208 U \u2286 A.", "sideBar": true}, {"type": "axiom", "content": "138", "name": "A point x is an interior point of A if A is a neighborhood of x.", "sideBar": true}, {"type": "axiom", "content": "139", "name": "The interior of a set A is the set of all its interior points.", "sideBar": true}, {"type": "text", "content": "140"}, {"type": "lean", "content": "141", "hidden": true}, {"type": "lean", "content": "142", "hidden": true}, {"type": "lean", "content": "143", "hidden": true}, {"type": "lean", "content": "144", "hidden": true}, {"type": "lemma", "text": "145", "lean": "lemma interior_is_subset: interior A \u2286 A :=\n", "sideBar": true, "firstProofLineNumber": 35, "lastProofLineNumber": 45, "textBefore": "import basic_defs_world.level1 -- hide\n\n/- Axiom : A set A is the neighborhood of a point x if there is an open U such that x \u2208 U \u2286 A.\nis_neighborhood : \u2203 U, is_open U \u2227 x \u2208 U \u2227 U \u2286 A\n-/\n\n/- Axiom : A point x is an interior point of A if A is a neighborhood of x.\nis_interior_point : is_neighborhood x A\n-/\n\n/- Axiom : The interior of a set A is the set of all its interior points. \ninterior := { x : X | is_interior_point x A }\n-/\n\n/-\nIn this world we will end up having three alternative definitions of the interior of a set. \nThis will be very useful, because at any point we will be able to choose the one that better fits our needs.\n\nFirst of all we need to figure out what properties does the interior of an arbitrary set have... So we start with an easy one:\n\n# Level 1: The interior is contained in the original set\n\n-/\nvariables {X : Type} -- hide\nvariables [topological_space X] (x : X)  (A : set X) -- hide\n\nnamespace topological_space -- hide\n\n@[simp]  -- hide\n/- Lemma\nThe interior of any set A is contained in the set A.\n-/\nlemma interior_is_subset: interior A \u2286 A :=\nbegin\n", "proof": "  rintros x \u27e8_, _\u27e9,\n  tauto,\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend topological_space -- hide\n", "height": 11, "editorText": "sorry", "lineOffset": 34, "name": "interior_is_subset", "statement": "interior A \u2286 A"}, {"type": "lean", "content": "146", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/interior_world/level1.lean"}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "147", "hidden": true}, {"type": "text", "content": "148"}, {"type": "lean", "content": "149", "hidden": true}, {"type": "lean", "content": "150", "hidden": true}, {"type": "lean", "content": "151", "hidden": true}, {"type": "lemma", "text": "152", "lean": "lemma interior_def' : interior A = \u22c3\u2080 {U : set X | is_open U \u2227 U \u2286 A} :=\n", "sideBar": true, "firstProofLineNumber": 23, "lastProofLineNumber": 33, "textBefore": "import interior_world.level1 --hide\n\n\n/-\n\n# Level 2: Second definition of the interior\n\nBefore we keep proving properties of the iterior of an arbitrary set, we will prove an alternative definition of it.\n\n-/\nvariables {X : Type} -- hide\nvariables [topological_space X] (x : X)  (A : set X) -- hide\n\nnamespace topological_space -- hide\n\n\n/- Lemma\nThe interior of a set A is the union of all the open sets that it contains:\n$ \\operatorname{int}(A) = \\bigcup_{U \\subseteq A, U\\text{ open}} U$\n-/\nlemma interior_def' : interior A = \u22c3\u2080 {U : set X | is_open U \u2227 U \u2286 A} :=\nbegin\n", "proof": "  simp only [interior, is_neighborhood, set.sUnion],\n  ext,\n  norm_num,\n  tauto,\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend topological_space -- hide\n", "height": 11, "editorText": "sorry", "lineOffset": 22, "name": "interior_def'", "statement": "interior A = \u22c3\u2080 {U : set X | is_open U \u2227 U \u2286 A}"}, {"type": "lean", "content": "153", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/interior_world/level2.lean"}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "154", "hidden": true}, {"type": "text", "content": "155"}, {"type": "lean", "content": "156", "hidden": true}, {"type": "lean", "content": "157", "hidden": true}, {"type": "lean", "content": "158", "hidden": true}, {"type": "lemma", "text": "159", "lean": "@[simp] lemma interior_is_open : is_open (interior A) :=\n", "sideBar": true, "firstProofLineNumber": 20, "lastProofLineNumber": 34, "textBefore": "import interior_world.level2 --hide\n\n/-\n\n# Level 3: The interior is open\n\n\n\n-/\nvariables {X : Type} -- hide\nvariables [topological_space X] (x : X)  (A : set X) -- hide\n\nnamespace topological_space -- hide\n\n/- Lemma\nThe interior of a set is open.\n-/\n@[simp] lemma interior_is_open : is_open (interior A) :=\nbegin\n", "proof": "  rw interior_def',\n  apply union,\n  rintros B \u27e8is_open_B, _\u27e9,\n  exact is_open_B,\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend topological_space -- hide\n", "height": 15, "editorText": "sorry", "lineOffset": 19, "name": "lemma", "statement": "interior_is_open : is_open (interior A)"}, {"type": "lean", "content": "160", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/interior_world/level3.lean"}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "161", "hidden": true}, {"type": "text", "content": "162"}, {"type": "lean", "content": "163", "hidden": true}, {"type": "lean", "content": "164", "hidden": true}, {"type": "lean", "content": "165", "hidden": true}, {"type": "lemma", "text": "166", "lean": "lemma interior_maximal (B : set X) (h : B \u2286 A) (hopen : is_open B):\n  B \u2286 interior A :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 34, "textBefore": "import interior_world.level3 --hide\n\n/-\n\n# Level 4: The interior is the maximal open subset\n\n\n\n-/\nvariables {X : Type} -- hide\nvariables [topological_space X] (x : X)  (A : set X) -- hide\n\nnamespace topological_space -- hide\n\n/- Lemma\nIf B is an open set contained in A, then B is contained in the interior of A.\n-/\nlemma interior_maximal (B : set X) (h : B \u2286 A) (hopen : is_open B):\n  B \u2286 interior A :=\nbegin\n", "proof": "  intros x x_in_B,\n  rw interior_def',\n  use B,\n  exact \u27e8\u27e8hopen, h\u27e9, x_in_B\u27e9,\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend \n\nend topological_space -- hide\n", "height": 14, "editorText": "sorry", "lineOffset": 20, "name": "interior_maximal", "statement": "(B : set X) (h : B \u2286 A) (hopen : is_open B):\n  B \u2286 interior A"}, {"type": "lean", "content": "167", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/interior_world/level4.lean"}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "168", "hidden": true}, {"type": "text", "content": "169"}, {"type": "lean", "content": "170", "hidden": true}, {"type": "lean", "content": "171", "hidden": true}, {"type": "lean", "content": "172", "hidden": true}, {"type": "lemma", "text": "173", "lean": "lemma interior_def'': is_open B \u2227 B \u2286 A \u2227 (\u2200 U, U \u2286 A \u2192 is_open U \u2192 U \u2286 B) \u2194 B = interior A :=   \n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 49, "textBefore": "import interior_world.level4 --hide\n/-\n\n# Level 5: Characterization of the interior\n\n\n\n-/\nvariables {X : Type} -- hide\nvariables [topological_space X] (x : X)  (A B : set X) -- hide\n\nnamespace topological_space -- hide\n\n/- Lemma\nThe interior of a set A is the biggest subset satisfying:\n - It is contained in A\n - It is open.\n-/\nlemma interior_def'': is_open B \u2227 B \u2286 A \u2227 (\u2200 U, U \u2286 A \u2192 is_open U \u2192 U \u2286 B) \u2194 B = interior A :=   \nbegin\n", "proof": "  split,\n  {\n    rintros \u27e8is_open_B, \u27e8B_subset_A, B_is_biggest_open\u27e9\u27e9,\n    ext1,\n    split,\n    {\n      apply interior_maximal A B B_subset_A is_open_B,\n    },\n    {\n      intro ha,\n      exact B_is_biggest_open (interior A) (interior_is_subset A) (interior_is_open A) ha,\n    },\n  },\n  {\n    intro,\n    subst B,\n    exact \u27e8interior_is_open A, \u27e8interior_is_subset A, interior_maximal A\u27e9\u27e9,\n  },\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend \n\nend topological_space -- hide\n", "height": 29, "editorText": "sorry", "lineOffset": 20, "name": "interior_def''", "statement": "is_open B \u2227 B \u2286 A \u2227 (\u2200 U, U \u2286 A \u2192 is_open U \u2192 U \u2286 B) \u2194 B = interior A"}, {"type": "lean", "content": "174", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/interior_world/level5.lean"}], "parents": [2]}, {"name": "175", "levels": [{"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "176", "hidden": true}, {"type": "axiom", "content": "177", "name": "A topological space is a T\u2080 space if, from any two points in the topology, there exist and open set that contains one point and not the other", "sideBar": true}, {"type": "axiom", "content": "178", "name": "A topological space is a T\u2081 space if, from any two points in the topology, there exist and open set that contains the first point and not the second", "sideBar": true}, {"type": "text", "content": "179"}, {"type": "lean", "content": "180", "hidden": true}, {"type": "lean", "content": "181", "hidden": true}, {"type": "lean", "content": "182", "hidden": true}, {"type": "lemma", "text": "183", "lean": "lemma T1_is_T0: T1_space X \u2192 T0_space X :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 39, "textBefore": "import basic_defs_world.level1 -- hide\n\n/- Axiom : A topological space is a T\u2080 space if, from any two points in the topology, there exist and open set that contains one point and not the other\nt0 : \u2200 (x y : X) (h : y \u2260 x) , \u2203 (U : set X) (hU : is_open U), ((x \u2208 U) \u2227 (y \u2209 U)) \u2228 ((x \u2209 U) \u2227 (y \u2208 U))\n-/\n\n/- Axiom : A topological space is a T\u2081 space if, from any two points in the topology, there exist and open set that contains the first point and not the second\nt1 : \u2200 (x y : X) (h : y \u2260 x), \u2203 (U : set X) (hU : is_open U), (x \u2208 U) \u2227 (y \u2209 U)\n-/\n\n/-\n\n# Level 1: Every Frechet space is a T\u2080 space\n\n-/\nvariables {X : Type} -- hide\nvariables [topological_space X] -- hide\n\nnamespace topological_space -- hide\n\n/- Lemma\nLet \u03c4 be a topological space. If \u03c4 is a frechet space is also a T\u2080.\n-/\nlemma T1_is_T0: T1_space X \u2192 T0_space X :=\nbegin\n", "proof": "  introI t1,\n  fconstructor,\n  intros x y hxy,\n  obtain \u27e8U, hU, hh\u27e9:= T1_space.t1 x y hxy,\n  exact \u27e8U, hU, or.inl hh\u27e9,\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend topological_space -- hide\n", "height": 14, "editorText": "sorry", "lineOffset": 25, "name": "T1_is_T0", "statement": "T1_space X \u2192 T0_space X"}, {"type": "lean", "content": "184", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/separation_world/level1.lean"}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "185", "hidden": true}, {"type": "text", "content": "186"}, {"type": "lean", "content": "187", "hidden": true}, {"type": "lean", "content": "188", "hidden": true}, {"type": "lean", "content": "189", "hidden": true}, {"type": "lemma", "text": "190", "lean": "lemma T1_space_iff_T1_space' : T1_space X \u2194 T1_space' X:=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 31, "textBefore": "import separation_world.level1 -- hide\n\n/-\n# Level 2: Comparison between the definition given and common definition of T\u2081\n-/\n\nvariables {X : Type} -- hide\nvariables [topological_space X] -- hide\n\nnamespace topological_space -- hide\n\n\n/- Lemma\nThe definitions T1_space and T1_space' are equivalent.\n-/\nlemma T1_space_iff_T1_space' : T1_space X \u2194 T1_space' X:=\nbegin\n", "proof": "  split; introI h,\n  { fconstructor,\n    intros x y hxy,\n    obtain \u27e8U, hU, hhU\u27e9 := T1_space.t1 x y hxy,\n    obtain \u27e8V, hV, hhV\u27e9 := T1_space.t1 y x (ne.symm hxy),\n    exact \u27e8U, V, hU, hV, hhU.1, hhU.2, hhV.2, hhV.1\u27e9},\n  { fconstructor,\n    intros x y hxy,\n    obtain \u27e8U, V, hU, hV, hh\u27e9 := T1_space'.t1 x y hxy,\n    exact \u27e8U, hU, \u27e8hh.1,hh.2.1\u27e9\u27e9},\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend topological_space -- hide\n", "height": 14, "editorText": "sorry", "lineOffset": 17, "name": "T1_space_iff_T1_space'", "statement": "T1_space X \u2194 T1_space' X"}, {"type": "lean", "content": "191", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/separation_world/level2.lean"}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "192", "hidden": true}, {"type": "text", "content": "193"}, {"type": "lean", "content": "194", "hidden": true}, {"type": "lean", "content": "195", "hidden": true}, {"type": "lean", "content": "196", "hidden": true}, {"type": "lean", "content": "197", "hidden": true}, {"type": "lemma", "text": "198", "lean": "lemma union_disjont_open_sets [T1_space X] {x : X}: \u22c3\u2080 {U : set X | (x \u2209 U) \u2227 (is_open U)} = {x}\u1d9c :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 24, "textBefore": "import separation_world.level2 -- hide\n\n/-\n# Level 3: Lemma about intersection of open sets\n-/\n\nvariables {X : Type} -- hide\nvariables [topological_space X] -- hide\n\nnamespace topological_space -- hide\nopen set -- hide\n\n/- Lemma\nLet \u03c4 be a topological space. \u03c4 is a frechet space if only if for all the points in the topology, their singletons are closed sets.\n-/\nlemma union_disjont_open_sets [T1_space X] {x : X}: \u22c3\u2080 {U : set X | (x \u2209 U) \u2227 (is_open U)} = {x}\u1d9c :=\nbegin\n", "proof": "  apply subset.antisymm; intros t ht, \n  { rcases ht with \u27e8A,\u27e8hxA, hA\u27e9, htA\u27e9,\n    rw [mem_compl_eq, mem_singleton_iff],\n    rintro rfl,\n    contradiction},\n  { obtain \u27e8U, hU, hh\u27e9 := T1_space.t1 t x (mem_compl_singleton_iff.mp ht).symm,\n    exact \u27e8U, \u27e8hh.2, hU\u27e9, hh.1\u27e9},", "proof_hint": "sorry", "textAfter": "\nend\n\nend topological_space -- hide\n", "height": 7, "editorText": "sorry", "lineOffset": 17, "name": "union_disjont_open_sets", "statement": "[T1_space X] {x : X}: \u22c3\u2080 {U : set X | (x \u2209 U) \u2227 (is_open U)} = {x}\u1d9c"}, {"type": "lean", "content": "199", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/separation_world/level3.lean"}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "200", "hidden": true}, {"type": "text", "content": "201"}, {"type": "lean", "content": "202", "hidden": true}, {"type": "lean", "content": "203", "hidden": true}, {"type": "lean", "content": "204", "hidden": true}, {"type": "lean", "content": "205", "hidden": true}, {"type": "lemma", "text": "206", "lean": "lemma T1_characterisation : T1_space X \u2194 (\u2200 (x : X), is_closed ({x} : set X)) :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 23, "textBefore": "import separation_world.level3 -- hide\n\n/-\n# Level 4: Characterisation of Frechet spaces\n-/\n\nvariables {X : Type} -- hide\nvariables [topological_space X] -- hide\n\nnamespace topological_space -- hide\nopen set -- hide\n\n/- Lemma\nLet \u03c4 be a topological space. \u03c4 is a frechet space if only if for all the points in the topology, their singletons are closed sets.\n-/\nlemma T1_characterisation : T1_space X \u2194 (\u2200 (x : X), is_closed ({x} : set X)) :=\nbegin\n", "proof": "  split,\n  { introsI t1 x,\n    rw [is_closed, \u2190 union_disjont_open_sets],\n    exact topological_space.union (\u03bb B hB, hB.2)},\n  { intro h, \n    exact \u27e8\u03bb x y hxy, \u27e8{y}\u1d9c,h y, mem_compl_singleton_iff.mpr (ne.symm hxy), not_not.mpr rfl\u27e9\u27e9}", "proof_hint": "sorry", "textAfter": "\nend\n\nend topological_space -- hide\n", "height": 6, "editorText": "sorry", "lineOffset": 17, "name": "T1_characterisation", "statement": "T1_space X \u2194 (\u2200 (x : X), is_closed ({x} : set X))"}, {"type": "lean", "content": "207", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/separation_world/level4.lean"}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "208", "hidden": true}, {"type": "text", "content": "209"}, {"type": "lean", "content": "210", "hidden": true}, {"type": "lean", "content": "211", "hidden": true}, {"type": "lean", "content": "212", "hidden": true}, {"type": "lean", "content": "213", "hidden": true}, {"type": "lemma", "text": "214", "lean": "lemma T2_space.T1_space [T2_space X]: T1_space X  :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 24, "textBefore": "import separation_world.level4 -- hide\n\n/-\n# Level 5: Every T\u2082 space is also T\u2081\n-/\n\nvariables {X : Type} -- hide\nvariables [topological_space X] -- hide\n\nnamespace topological_space -- hide\nopen set -- hide\n\n/- Lemma\nLet \u03c4 be a topological space. \u03c4 is a frechet space if only if for all the points in the topology, their singletons are closed sets.\n-/\nlemma T2_space.T1_space [T2_space X]: T1_space X  :=\nbegin\n", "proof": "  exact {t1 := \u03bb x y hxy, let \u27e8U, V, hU, hV, hUV, hh\u27e9  := T2_space.t2 x y hxy in \n          \u27e8U, hU, hh.1, not.imp (not_not.mpr hh.2) (\u03bb c, (subset_compl_iff_disjoint.2 hUV) c)\u27e9 }\n\n\n\n\n          ", "proof_hint": "sorry", "textAfter": "\nend\n\nend topological_space -- hide\n", "height": 7, "editorText": "sorry", "lineOffset": 17, "name": "T2_space.T1_space", "statement": "[T2_space X]: T1_space X"}, {"type": "lean", "content": "215", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/separation_world/level5.lean"}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "216", "hidden": true}, {"type": "text", "content": "217"}, {"type": "lean", "content": "218", "hidden": true}, {"type": "lean", "content": "219", "hidden": true}, {"type": "lean", "content": "220", "hidden": true}, {"type": "lean", "content": "221", "hidden": true}, {"type": "lemma", "text": "222", "lean": "lemma T3_space.T1_space [T3_space X]: T1_space X  :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 30, "textBefore": "import separation_world.level5 -- hide\n\n/-\n# Level 6: Characterisation of Frechet spaces\n-/\n\nvariables {X : Type} -- hide\nvariables [topological_space X] -- hide\n\nnamespace topological_space -- hide\nopen set -- hide\n\n/- Lemma\nLet \u03c4 be a topological space. \u03c4 is a frechet space if only if for all the points in the topology, their singletons are closed sets.\n-/\nlemma T3_space.T1_space [T3_space X]: T1_space X  :=\nbegin\n", "proof": "  fconstructor,\n  intros x y hxy,\n  obtain \u27e8U, hU, hh\u27e9 := T0_space.t0 x y hxy,\n  cases hh,\n  { exact \u27e8U, hU, hh\u27e9},\n  { obtain \u27e8A, B, hA, hB, hAB, hhAB\u27e9 := T3_space.regular y U\u1d9c (by rwa [is_closed, compl_compl]) \n                                          (\u03bb t, (not_mem_of_mem_compl t) hh.2),\n    exact \u27e8B, hB, hhAB.2 hh.1, (disjoint_left.1 (disjoint_iff_inter_eq_empty.2 hAB) hhAB.1)\u27e9}\n\n\n\n    \n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend topological_space -- hide\n", "height": 13, "editorText": "sorry", "lineOffset": 17, "name": "T3_space.T1_space", "statement": "[T3_space X]: T1_space X"}, {"type": "lean", "content": "223", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/separation_world/level6.lean"}], "parents": [3]}, {"name": "224", "levels": [{"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "225", "hidden": true}, {"type": "lean", "content": "226", "hidden": true}, {"type": "lean", "content": "227", "hidden": true}, {"type": "text", "content": "228"}, {"type": "lean", "content": "229", "hidden": false}, {"type": "lemma", "text": "230", "lean": "lemma principal_is_filter {X : Type} (s : set X) : is_filter (principal' s):=\n", "sideBar": true, "firstProofLineNumber": 19, "lastProofLineNumber": 32, "textBefore": "import filter_world.definition --hide\n\nopen set --hide\nnamespace filters --hide\n\n\n/-\n# Level 1: The principal filter of a subset\n-/\n\ndef principal' {X : Type} (s : set X) := {t | s \u2286 t}\n\n\n/- Lemma\nThe collection of subsets defined before have a filter structure.\n-/\nlemma principal_is_filter {X : Type} (s : set X) : is_filter (principal' s):=\nbegin\n", "proof": "  fconstructor,\n  {\n    exact subset_univ s\n  },\n  {\n    intros A B hA hAB,\n    exact subset.trans hA hAB\n  },\n  {\n    intros A B hA hB,\n    exact subset_inter hA hB\n  }\n\n", "proof_hint": "sorry", "textAfter": "\nend\n    \n\nlocalized \"notation `P` := principal\" in filters -- hide\n\nend filters --hide\n", "height": 14, "editorText": "sorry", "lineOffset": 18, "name": "principal_is_filter", "statement": "{X : Type} (s : set X) : is_filter (principal' s)"}, {"type": "lean", "content": "231", "hidden": true}, {"type": "lean", "content": "232", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/filter_world/level1.lean"}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "233", "hidden": true}, {"type": "lean", "content": "234", "hidden": true}, {"type": "lean", "content": "235", "hidden": true}, {"type": "lean", "content": "236", "hidden": true}, {"type": "lean", "content": "237", "hidden": true}, {"type": "axiom", "content": "238", "name": "", "sideBar": true}, {"type": "text", "content": "239"}, {"type": "lemma", "text": "240", "lean": "lemma univ_filter_univ {X : Type}: \u2200 (A : set X), A \u2208 P (univ : set X) \u2194 A = univ :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 38, "textBefore": "import filter_world.level1 --hide\n\nopen set --hide\nnamespace filters --hide\nlocalized \"notation `P` := principal\" in filters --hide\n\nlemma mem_principal {X : Type} {s t : set X} : s \u2208 P t \u2194 t \u2286 s := iff.rfl -- hide\n\n/- Axiom :\nmem_principal : s \u2208 P t \u2194 t \u2286 s\n-/\n\n/-\n# Level 2: Characterization of the princial filter of the total set\n-/\n\n/- Lemma\nThe only element of the principal filter of the universal set is the universal set.\n-/\nlemma univ_filter_univ {X : Type}: \u2200 (A : set X), A \u2208 P (univ : set X) \u2194 A = univ :=\nbegin\n", "proof": "  intros A,\n  split; intro hA,\n  {\n    rw mem_principal at hA,\n    ext,\n    split,\n    { intro hx,\n      exact mem_univ x },\n    { intro hx,\n      exact hA hx }\n  },\n  {\n    rw mem_principal,\n    rw hA\n  }\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend filters --hide\n", "height": 17, "editorText": "sorry", "lineOffset": 21, "name": "univ_filter_univ", "statement": "{X : Type}: \u2200 (A : set X), A \u2208 P (univ : set X) \u2194 A = univ"}, {"type": "lean", "content": "241", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/filter_world/level2.lean"}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "242", "hidden": true}, {"type": "lean", "content": "243", "hidden": true}, {"type": "lean", "content": "244", "hidden": true}, {"type": "lean", "content": "245", "hidden": true}, {"type": "text", "content": "246"}, {"type": "lemma", "text": "247", "lean": "lemma top_bottom_filters {X : Type}: \u2203 (B T : filter X), \u2200 (F : filter X), B \u2264 F \u2227 F \u2264 T :=\n", "sideBar": true, "firstProofLineNumber": 15, "lastProofLineNumber": 33, "textBefore": "import filter_world.level2 --hide\nopen set --hide\nnamespace filters --hide\nlocalized \"notation `P` := principal\" in filters --hide\n\n/-\n# Level 3: The bottom filter\n-/\n\n/- Lemma\nThere exists a bottom filter among the filters of a given set.\n-/\nlemma top_bottom_filters {X : Type}: \u2203 (B T : filter X), \u2200 (F : filter X), B \u2264 F \u2227 F \u2264 T :=\nbegin\n", "proof": "  use P \u2205,\n  use P univ,\n  intro F,\n  split,\n  {\n    intros A hA,\n    have h_emp : (\u2205 : set X) \u2208 P (\u2205 : set X),\n    { rw mem_principal },\n    have h_emp_A : (\u2205 : set X) \u2286 A,\n    { exact empty_subset A },\n    exact filter.sets_of_superset (P \u2205) h_emp h_emp_A\n  },\n  {\n    intros A hA,\n    obtain h_uni := (univ_filter_univ A).1 hA,\n    rw h_uni,\n    exact filter.univ_sets F\n  }\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend filters --hide\n", "height": 19, "editorText": "sorry", "lineOffset": 14, "name": "top_bottom_filters", "statement": "{X : Type}: \u2203 (B T : filter X), \u2200 (F : filter X), B \u2264 F \u2227 F \u2264 T"}, {"type": "lean", "content": "248", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/filter_world/level3.lean"}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "249", "hidden": true}, {"type": "lean", "content": "250", "hidden": true}, {"type": "lean", "content": "251", "hidden": true}, {"type": "lean", "content": "252", "hidden": true}, {"type": "text", "content": "253"}, {"type": "lean", "content": "254", "hidden": false}, {"type": "lemma", "text": "255", "lean": "lemma is_filter_meet {X : Type} (V F : filter X): is_filter (meet_set' V F) :=\n", "sideBar": true, "firstProofLineNumber": 17, "lastProofLineNumber": 39, "textBefore": "import filter_world.level3 --hide\nopen set --hide\nnamespace filters --hide\nlocalized \"notation `P` := principal\" in filters --hide\n\n/-\n# Level 4: The meet of a pair of filters\n-/\n\ndef meet_set' {X : Type*} (V F : filter X) := {t | \u2203 (v \u2208 V) (f \u2208 F), v \u2229 f \u2286 t}\n\n/- Lemma\nThe collection of subsets defined before is a filter.\n-/\nlemma is_filter_meet {X : Type} (V F : filter X): is_filter (meet_set' V F) :=\nbegin\n", "proof": "  fconstructor,\n  {\n    exact \u27e8univ, V.univ_sets, univ, F.univ_sets, (univ \u2229 univ).subset_univ\u27e9\n  },\n  {\n    rintros A B \u27e8v, hv, f, hf, H\u27e9 hAB,\n    exact \u27e8v, hv, f, hf, subset.trans H hAB\u27e9\n  },\n  {\n    rintros A B \u27e8v\u2081, hv\u2081, f\u2081, hf\u2081, H\u2081\u27e9 \u27e8v\u2082, hv\u2082, f\u2082, hf\u2082, H\u2082\u27e9,\n    have : v\u2081 \u2229 v\u2082 \u2229 (f\u2081 \u2229 f\u2082) = v\u2081 \u2229 f\u2081 \u2229 (v\u2082 \u2229 f\u2082),\n      by rwa [\u2190 inter_assoc, inter_assoc v\u2081, inter_comm v\u2082, \u2190 inter_assoc, \u2190 inter_assoc],\n    obtain hvf := inter_subset_inter H\u2081 H\u2082,\n    exact \u27e8v\u2081 \u2229 v\u2082, V.inter_sets hv\u2081 hv\u2082, f\u2081 \u2229 f\u2082, F.inter_sets hf\u2081 hf\u2082, by rwa this\u27e9,\n  }\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\ndef meet {\u03b1 : Type*} (V F : filter \u03b1) : filter \u03b1 := --hide\n{ sets := {t | \u2203 (v f : set \u03b1), v \u2208 V \u2227 f \u2208 F \u2227 v \u2229 f \u2286 t }, --hide\n  univ_sets := \u27e8univ, univ, V.univ_sets, F.univ_sets, (univ \u2229 univ).subset_univ\u27e9, --hide\n  sets_of_superset := (\u03bb A B \u27e8v, f, hv, hf, H\u27e9 hAB, \u27e8v, f, hv, hf, subset.trans H hAB\u27e9), --hide\n  inter_sets := --hide\n  begin --hide\n    rintros A B \u27e8v\u2081, f\u2081, hv\u2081, hf\u2081, H\u2081\u27e9 \u27e8v\u2082, f\u2082, hv\u2082, hf\u2082, H\u2082\u27e9, --hide\n    have : v\u2081 \u2229 v\u2082 \u2229 (f\u2081 \u2229 f\u2082) = v\u2081 \u2229 f\u2081 \u2229 (v\u2082 \u2229 f\u2082), --hide\n      by rwa [\u2190 inter_assoc, inter_assoc v\u2081, inter_comm v\u2082, \u2190 inter_assoc, \u2190 inter_assoc], --hide\n    obtain hvf := inter_subset_inter H\u2081 H\u2082, --hide\n    exact \u27e8v\u2081 \u2229 v\u2082, f\u2081 \u2229 f\u2082, V.inter_sets hv\u2081 hv\u2082, F.inter_sets hf\u2081 hf\u2082, by rwa this\u27e9 --hide\n  end } --hide\n\nend filters --hide", "height": 23, "editorText": "sorry", "lineOffset": 16, "name": "is_filter_meet", "statement": "{X : Type} (V F : filter X): is_filter (meet_set' V F)"}, {"type": "lean", "content": "256", "hidden": true}, {"type": "lean", "content": "257", "hidden": true}, {"type": "lean", "content": "258", "hidden": true}, {"type": "lean", "content": "259", "hidden": true}, {"type": "lean", "content": "260", "hidden": true}, {"type": "lean", "content": "261", "hidden": true}, {"type": "lean", "content": "262", "hidden": true}, {"type": "lean", "content": "263", "hidden": true}, {"type": "lean", "content": "264", "hidden": true}, {"type": "lean", "content": "265", "hidden": true}, {"type": "lean", "content": "266", "hidden": true}, {"type": "lean", "content": "267", "hidden": true}, {"type": "lean", "content": "268", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/filter_world/level4.lean"}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "269", "hidden": true}, {"type": "lean", "content": "270", "hidden": true}, {"type": "lean", "content": "271", "hidden": true}, {"type": "lean", "content": "272", "hidden": true}, {"type": "text", "content": "273"}, {"type": "lemma", "text": "274", "lean": "lemma meet_greatest_lower_bound {X : Type} (V F : filter X): \u2200 (T : filter X), \n    T \u2264 V \u2227 T \u2264 F \u2192 T \u2264 meet V F :=\n", "sideBar": true, "firstProofLineNumber": 17, "lastProofLineNumber": 31, "textBefore": "import filter_world.level4 --hide\nopen set --hide\nnamespace filters --hide\nlocalized \"notation `P` := principal\" in filters --hide\n\n/-\n# Level 5: The meet filter of two filters, greates lower bound\n-/\n\n\n/- Lemma\nThe meet of two filters is their greatest lower bound. \n-/\nlemma meet_greatest_lower_bound {X : Type} (V F : filter X): \u2200 (T : filter X), \n    T \u2264 V \u2227 T \u2264 F \u2192 T \u2264 meet V F :=\nbegin\n", "proof": "  intros T hVF A hA,\n  obtain \u27e8v, f, hv, hf, H\u27e9 := hA,\n  have hfv : v \u2229 f \u2208 T,\n  {\n    exact T.inter_sets (hVF.1 hv) (hVF.2 hf)\n  },\n  exact T.sets_of_superset hfv H,\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend filters --hide", "height": 15, "editorText": "sorry", "lineOffset": 16, "name": "meet_greatest_lower_bound", "statement": "{X : Type} (V F : filter X): \u2200 (T : filter X), \n    T \u2264 V \u2227 T \u2264 F \u2192 T \u2264 meet V F"}, {"type": "lean", "content": "275", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/filter_world/level5.lean"}], "parents": [4]}, {"name": "276", "levels": [{"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "277", "hidden": true}, {"type": "text", "content": "278"}, {"type": "lean", "content": "279", "hidden": true}, {"type": "lean", "content": "280", "hidden": true}, {"type": "lean", "content": "281", "hidden": true}, {"type": "lean", "content": "282", "hidden": true}, {"type": "lemma", "text": "283", "lean": "lemma open_iff_eq_closure : is_open A \u2194 interior A = A :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 41, "textBefore": "import interior_world.level5 --hide\n\n\n\n/-\n\n# Level 2: Second definition of the interior\n\nBefore we keep proving properties of the iterior of an arbitrary set, we will prove an alternative definition of it.\n\n-/\nvariables {X : Type} -- hide\nvariables [topological_space X] (x : X)  (A : set X) -- hide\nopen set --hide\nnamespace topological_space -- hide\n\n\n/- Lemma\nThe interior of a set A is the union of all the open sets that it contains:\n$ \\operatorname{int}(A) = \\bigcup_{U \\subseteq A, U\\text{ open}} U$\n-/\nlemma open_iff_eq_closure : is_open A \u2194 interior A = A :=\nbegin\n", "proof": "  split; intro h,\n  {\n    apply subset.antisymm,\n    {\n      exact interior_is_subset A\n    },\n    {\n      rw interior_def',\n      intros x hx,\n      exact \u27e8A, \u27e8h, rfl.subset\u27e9, hx\u27e9\n    }\n  },\n  {\n    rw \u2190 h,\n    exact interior_is_open A\n  }\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend topological_space -- hide\n", "height": 18, "editorText": "sorry", "lineOffset": 23, "name": "open_iff_eq_closure", "statement": "is_open A \u2194 interior A = A"}, {"type": "lean", "content": "284", "hidden": true}], "url": "https://mmasdeu.github.io/topologygame/editor/#url=https://raw.githubusercontent.com/mmasdeu/topologygame/main/src/open_and_closed_world/level1.lean"}], "parents": [5]}], "texts": [["Lean Topology game", "# The Topology Game, version 1.0.0.\n\n## By the Barcelona Lean Seminar\n\nLearn topology with Lean!\n\n# What is this game?\n\nIn this game, you will learn topology and Lean at the same time. Travel through different worlds solving challenges. On the left side \nof the screen you will find tactics and theorems you can use.\n\nHave fun!\n\n# Credits\n\nThe Topology Game is brought to you by the Barcelona Lean Seminar, a project based at Universitat Aut\u00f2noma de Barcelona.\n\nLean is a computer theorem prover being developed at Microsoft Research.\n\nProve a theorem. Write a function. <a href=\"https://twitter.com/XenaProject\" target=\"blank\">@XenaProject</a>.\n", "Set theory", "\n## Summary\n\n`refl` is a tactic which proves goals of the form `X = X`.\n\n## Details\n\nThe `refl` tactic will close any goal of the form `A = B`\nwhere `A` and `B` are *exactly the same thing*.\n\n### Example:\nIf it looks like this in the top right hand box:\n```\nA B : set X\n\u22a2 A \u222a B = A \u222a B\n```\n\nthen\n\n`refl,`\n\nwill close the goal and solve the level. Don't forget the comma.\n\n", "We will start by practising with the simplest tactic, namely *refl*. This just proves goals\nof the form $A = A$, no matter how complicated $A$ is. Let's see it in action!\n", "Just delete `sorry` and type `refl,` (don't forget the comma!).\n", "Click here for a hint, in case you get stuck.", "variables {X : Type} -- hide\n", "If A and B are sets, then A \u222a B = A \u222a B.\n", "\n## Summary\n\nIf `h` is a proof of `X = Y`, then `rw h,` will change\nall `X`s in the goal to `Y`s. \n\n**Variants:** `rw \u2190 h` changes\n`Y` to `X` and\n`rw h at h2` changes `X` to `Y` in hypothesis `h2` instead\nof the goal.\n\n**Variant (rw and assumption):** If instead you use `rwa h` or `rwa \u2190 h`, Lean does performs\nthe `rw` and then looks whether\nthe goal is exactly one of your assumptions, in which case it closes it.\n\n## Details\n\nThe `rw` tactic is a way to do \"substituting in\". There\nare two distinct situations where use this tactics.\n\n1) If `h : A = B` is a hypothesis (i.e., a proof of `A = B`)\nin your local context (the box in the top right)\nand if your goal contains one or more `A`s, then `rw h`\nwill change them all to `B`'s. \n\n2) The `rw` tactic will also work with proofs of theorems\nwhich are equalities (look for them in the drop down\nmenu on the left, within Theorem Statements).\n\n**Important note:** if `h` is not a proof of the form `A = B`\nor `A \u2194 B` (for example if `h` is a function, an implication,\nor perhaps even a proposition itself rather than its proof),\nthen `rw` is not the tactic you want to use. For example,\n`rw (P = Q)` is never correct: `P = Q` is the true-false\nstatement itself, not the proof.\nIf `h : P = Q` is its proof, then `rw h` will work.\n\n**Pro tip 1:** If `h : A = B` and you want to change\n`B`s to `A`s instead, try `rw \u2190h` (get the arrow with `\\l`,\nnote that this is a small letter L, not a number 1).\n\n### Example:\nIf it looks like this in the top right hand box:\n```\nA B C : set X\nh : A = B \u222a C\n\u22a2 A \u222a B = B \u222a C\n```\n\nthen\n\n`rw h,`\n\nwill change the goal into `\u22a2 B \u222a C \u222a B = B \u222a C`.\n\n### Example: \nYou can use `rw` to change a hypothesis as well. \nFor example, if your local context looks like this:\n```\nA B C D : set X\nh1 : A = B \u2229 C\nh2 : B \u222a A = D\n\u22a2 D = B\n```\nthen `rw h1 at h2` will turn `h2` into `h2 : B \u222a B \u2229 C = D` (remember operator precedence).\n\n", "The next tactic we will learn is *rw* (from rewrite). It rewrites equalities. That is,\nif we have a proof `h : A = B` and we want to prove `\u22a2 A \u2229 C = B \u2229 C`, then after `rw h` the goal\nwill become `\u22a2 A \u2229 C = A \u2229 C`, which seems reasonable.\n\nAfter many tactics (and `rw` is one of them) Lean tries to apply `refl`. This is why\nin the following proof you may get away with only one tactic application.\n\n", "Delete `sorry` and type `rw h,` (don't forget the comma!). Lean tries `refl` afterwards,\nso you will see that this suffices.\n", "Click here for a hint, in case you get stuck.", "variables {X : Type} -- hide\n", "If A, B and C are sets and A = B, then A \u222a C = B \u222a C.\n", "\n## Summary \n\nIf the goal is `\u22a2 X` then `exact x` will close the goal if\nand only if `x` is a term of type `X`. \n\n## Details\n\nSay $P$, $Q$ and $R$ are types (i.e., what a mathematician\nmight think of as either sets or propositions),\nand the local context looks like this: \n\n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\n\nIf you can spot how to make a term of type `R`, then you\ncan just make it and say you're done using the `exact` tactic\ntogether with the formula you have spotted. For example the\nabove goal could be solved with\n\n`exact j(h(p)),`\n\nbecause $j(h(p))$ is easily checked to be a term of type $R$\n(i.e., an element of the set $R$, or a proof of the proposition $R$).\n\n", "In this level we learn the tactic `exact`, which solves a goal that is exactly one of the hypotheses.\n", "By doing a `rw` you will get the goal to look exactly like one of the hypotheses...\n", "Click here for a hint, in case you get stuck.", "variables {X : Type} -- hide\n", "If A and B are sets and x \u2208 A and A = B, then x \u2208 B.\n", "Try to solve this level with exactly one line, using the `rwa` tactic.\n", "variables {X : Type} -- hide\n", "Let A be a set and x \u2208 A, using the assumption A \u222a A = A, we obtain that x \u2208 B.\n", "\n## Summary:\n\n`intro p` will turn a goal `\u22a2 P \u2192 Q` into a hypothesis `p : P`\nand goal `\u22a2 Q`. If `P` and `Q` are sets `intro p` means \"let $p$ be an arbitrary element of $P$\".\nIf `P` and `Q` are propositions then `intro p` says \"assume $P$ is true\". \n\n## Details\n\nIf your goal is a function or an implication `\u22a2 P \u2192 Q` then `intro`\nwill always make progress. `intro p` turns\n\n`\u22a2 P \u2192 Q`\n\ninto \n\n```\np : P\n\u22a2 Q\n```\n\nThe opposite tactic to intro is `revert`; given the situation\njust above, `revert p` turns the goal back into `\u22a2 P \u2192 Q`.\n\n**Variant:** Instead of calling `intro` multiple times, you can use\n`intros`. That is, `intros h\u2081 h\u2082` is equivalent to `intro h\u2081, intro h\u2082`.\n\n## Example\n\nIf your goal is an implication $P\\implies Q$ then Lean writes\nthis as `\u22a2 P \u2192 Q`, and `intro p,` can be thought of as meaning\n\"let $p$ be a proof of $P$\", or more informally \"let's assume that\n$P$ is true\". The goal changes to `\u22a2 Q` and the hypothesis `p : P`\nappears in the local context.\n\n", "In this level we introduce the tactic `intro`. You will need it to get started.\n", "Try something like `intro h1,` and go from there.\n", "Click here for a hint, in case you get stuck.", "variables {X : Type} -- hide\n", "If A, B and C are sets and A = B, then A \u222a C = B \u222a C.\n", "import data.set.basic -- hide\n", "open set -- hide\n", "\n## Summary\n\nIf `h : P \u2192 Q` is a hypothesis, and the goal is `\u22a2 Q` then\n`apply h` changes the goal to `\u22a2 P`. \n\n## Details\n\nIf you have a function `h : P \u2192 Q` and your goal is `\u22a2 Q`\nthen `apply h` changes the goal to `\u22a2 P`. The logic is\nsimple: if you are trying to create a term of type `Q`,\nbut `h` is a function which turns terms of type `P` into\nterms of type `Q`, then it will suffice to construct a\nterm of type `P`. A mathematician might say: \"we need\nto construct an element of $Q$, but we have a function $h:P\\to Q$\nso it suffices to construct an element of $P$\". Or alternatively\n\"we need to prove $Q$, but we have a proof $h$ that $P\\implies Q$\nso it suffices to prove $P$\".\n\n", "In this level we introduce the new tactic `apply`. Look at what it does and try to solve it!\n", "Start with an `intro`, then try to `apply` the right hypothesis.\n", "Click here for a hint, in case you get stuck.", "variables {X Y : Type} -- hide\n", "If A, B and C are sets and x \u2208 A, and we know that x \u2208 A \u2192 x \u2208 B and that x \u2208 B \u2192 x \u2208 C, then\nwe can deduce that x \u2208 C.\n", "import data.set.basic -- hide\n", "open set -- hide\n", "There is an equivalence between set theory and logic, and Lean identifies these two.\n\nIn this equivalence, a logic statement P : X \u2192 true/false corresponds to the set\n$A = \\{ x : X | P(x) \\}$. Under this equivalence, logical implications P \u2192 Q translate into\nset inclusions A \u2286 B, and so on.\n\nThe goal of this lemma is to prove transitivity of set inclusion, giving almost the same\nproof as in the previous lemma.\n", "Start with `intro x,`, then do exactly as in the previous level.\n", "Click here for a hint, in case you get stuck.", "variables {X Y : Type} -- hide\n", "If A, B and C are sets and, and we know A \u2286 B and B \u2286 C, then\nwe have A \u2286 C.\n", "import data.set.basic -- hide\n", "open set -- hide\n", "\n## Summary\n\nChanges the goal to `\u22a2 false`.\n\n## Details\n\nThis may seem hard to prove,\nbut it is useful when we have a contradiction in the hypotheses.\n\nFor example, if we have `h : \u00ac P` as a hypothesis and we apply `exfalso`\nwe can then `apply h` to transform the goal into `\u22a2 P`.\n", "In Lean, the  negation `\u00ac P` of a statement is a shorthand for `P \u2192 false`. Therefore\nstart with `exfalso`, and remember that negation is the same as `\u2192 false`.\n", "Click here for a hint, in case you get stuck.", "variables {X Y : Type} -- hide\n", "We can prove that 1 equals 0 if we have a contradiction in our hypotheses.\n", "import data.set.basic -- hide\n", "import data.set.prod --hide\n", "open set -- hide\n", "variables {X Y : Type} -- hide\n", "\n## Summary:\n\nIf the goal is `P \u2227 Q` or `P \u2194 Q` then `split` will break it into two goals.\n\n## Details\n\nIf `P Q : Prop` and the goal is `\u22a2 P \u2227 Q`, then `split` will change it into\ntwo goals, namely `\u22a2 P` and `\u22a2 Q`. \n\nIf `P Q : Prop` and the goal is `\u22a2 P \u2194 Q`, then `split` will change it into\ntwo goals, namely `\u22a2 P \u2192 Q` and `\u22a2 Q \u2192 P`.  \n\n## Example:\n\nIf your local context (the top right window) looks like this\n```\nX : Type\nA B : set X\nx : X\n\u22a2 x \u2208 A \u2194 x \u2208 B\n```\n\nthen after\n\n`split,`\n\nit will look like this:\n\n```\n2 goals\nX : Type\nA B : set X\nx : X\n\u22a2 x \u2208 A \u2192 x \u2208 B\n\n\nX : Type\nA B : set X\nx : X\n\u22a2 x \u2208 B \u2192 x \u2208 A\n```\n", "In this level we will learn the `split` tactic. It breaks a goal `P \u2227 Q` into two goals (proving `P`, and then proving `Q`),\nand also breaks goals of the form `P \u2194 Q` into proving each of the implications separately.\n\nYou will need to use both features to accomplish this proof.\n", "Giving an element `p` of a product type `X \u00d7 Y` and two subsets `A \u2286 X` `B \u2286 Y`. The element \n`p` is the set `A \u00d7 B` (as sets) if only if the first component of `p` is in `A` and the second in `B`.\n", "import data.set.basic -- hide\n", "open set -- hide\n", "\n## Summary\n\nIf `A` and `B` are sets and the goal is `A = B`, then\nusing the `ext` tactic will change it to `x \u2208 A \u2194 x \u2208 B`.\n\nVariant: `ext y` will change the goal to `y \u2208 A \u2194 y \u2208 B`.\n\n## Details\n\nThis tactic applies the \"extensionality\" axiom of set theory,\nwhich says that two sets are equal iff for all `x`, `x` belongs\nto the first iff `x` belongs to the second.\n\n### Example:\nIf it looks like this in the top right hand box:\n```\nA B : set X\n\u22a2 A = B\n```\n\nthen\n\n`ext,`\n\nwill change the goal into\n```\nA B : set X\nx : X\n\u22a2 x \u2208 A \u2194 x \u2208 B\n```\n", "\n## Summary\n\n`left` and `right` work on the goal, and they change\n`\u22a2 P \u2228 Q` to `\u22a2 P` and `\u22a2 Q` respectively.\n\n## Details\n\nThe tactics `left` and `right` work on a goal which is a type with\ntwo constructors, the classic example being `P \u2228 Q`. \nTo prove `P \u2228 Q` it suffices to either prove `P` or prove `Q`,\nand once you know which one you are going for you can change\nthe goal with `left` or `right` to the appropriate choice.\n", "\n## Summary:\n\n`cases` is a tactic which works on hypotheses.\nIf `h : P \u2227 Q` or `h : P \u2194 Q` is a hypothesis then `cases h with h1 h2` will remove `h`\nfrom the list of hypotheses and replace it with the \"ingredients\" of `h`,\ni.e. `h1 : P` and `h2 : Q`, or `h1 : P \u2192 Q` and `h2 : Q \u2192 P`. Also\nworks with `h : P \u2228 Q` and `n : mynat`. \n\n## Details\n\nHow does one prove `P \u2227 Q`? The way to do it is to prove `P` and to\nprove `Q`. There are hence two ingredients which go into a proof of\n`P \u2227 Q`, and the `cases` tactic extracts them. \n\nMore precisely, if the local context contains\n```\nh : P \u2227 Q`\n```\n\nthen after the tactic `cases h with p q,` the local context will\nchange to\n```\np : P,\nq : Q\n```\nand `h` will disappear. \n\nSimilarly `h : P \u2194 Q` is proved by proving `P \u2192 Q` and `Q \u2192 P`,\nand `cases h with hpq hqp` will delete our assumption `h` and\nreplace it with\n```\nhpq : P \u2192 Q,\nhqp : Q \u2192 P\n```\n\nBe warned though -- `rw h` works with `h : P \u2194 Q` (`rw` works with\n`=` and `\u2194`), whereas you cannot rewrite with an implication.\n\n`cases` also works with hypotheses of the form `P \u2228 Q`. Here the situation\nis different however. \nTo prove `P \u2228 Q` you need to give either a proof of `P` *or* a proof\nof `Q`, so if `h : P \u2228 Q` then `cases h with p q` will change one goal\ninto two, one with `p : P` and the other with `q : Q`.\n", "The following lemma can be proved using `ext`, `split`, `cases`, `left`, `right` tactics. Learn what\nthey do in the side-bar, and use them to clear this goal.\n\nIf you are lazy, the `finish` tactic will take the fun out of this exercise. So try to not use it.\n", "variables {X Y : Type} -- hide\n", "The distributive property of \u2229 with respect to \u222a.\n", "import data.set.basic -- hide\n", "import data.set.finite -- hide\n", "open set -- hide\n", "\nIf P is a property of sets, to prove that P(s) is true for all *finite* sets s\nit is enough to prove it for the empty set (h\u2080) and to prove\n(h\u2081) that if s is a finite set and a \u2209 s then P(s) \u2192  P({a} \u222a s).\n\nfinite.induction_on {P : set \u03b1 \u2192 Prop} {s : set \u03b1} (h : finite s)\n  (h\u2080 : P \u2205) (h\u2081 : \u2200 {a s}, a \u2209 s \u2192 finite s \u2192 P s \u2192 P (insert a s)) : P s\n", "\nWe have x \u2208 {a} \u222a s if and only if x = a or x \u2208 s.\n\nmem_insert_iff {x a : \u03b1} {s : set \u03b1} : x \u2208 insert a s \u2194 x = a \u2228 x \u2208 s\n", "\nThe empty intersection is everything.\n\nsInter_empty : \u22c2\u2080 \u2205 = univ\n", "If T is a set of sets, and s is a set, the set-wise intersection \u22c2\u2080 (s \u222a T) equals s \u2229 \u22c2\u2080 T.\n\nsInter_insert (s : set \u03b1) (T : set (set \u03b1)) : \u22c2\u2080 (insert s T) = s \u2229 \u22c2\u2080 T\n\n", "This is the final level, and be advised that it is *much* harder than the previous ones.\n\nWe will use the following lemma when we start proving facts about topological spaces.\n\nIt seems clear that we want to use induction, so try to apply the `finite.induction_on`\nlemma.\n\nFor the base case you will need `sInter_empty`, while for inductive step the lemmas `sInter_insert`, `mem_insert_iff` may be useful. Check the sidebar for their meaning.\n", "variables {X Y : Type} -- hide\n", "If P is a property of sets which is closed under pairwise intersection then it is also closed under\narbitrary finite intersections.\n", "import data.set.basic -- hide\n", "import data.set.finite -- hide\n", "open set -- hide\n", "\n## Summary\nThe tactic use specializes the goal with a particular case. For example, if we want to prove the statement \"there exists a natural number which is odd\", we will need to provide a concrete number like 3. \n\n", "If A and B are subsets of a fixed set, then there exists a subset S such that S \u2286 A \u2229 B.\n", "Functions", "import data.set.basic -- hide\n", "import tactic -- hide\n", "# Level 1: The image of a union\n\nIn this level we prove that the image of a union of two sets if the union of their images.\n", "open set -- hide\n", "variables{X Y: Type} -- hide\n", "$ f(A \u222a B) = f(A) \u222a f(B) $\n", "import data.set.basic -- hide\n", "import tactic -- hide\n", "open set -- hide\n", "open set function -- hide\n", "variables {X Y I: Type} -- hide\n", "# Level 1: The image of an indexed union\n\nThis level is similar to the previous one. You can use a similar strategy.\n\n", "If f is a function and A\u1d62 are sets, then f(\u22c3 A\u1d62) = \u22c3 f(A\u1d62)\n", "import data.set.basic -- hide\n", "import tactic -- hide\n", "open set -- hide\n", "open set function -- hide\n", "variables {X Y I: Type} -- hide\n", "mem_preimage : (a \u2208 f \u207b\u00b9' s) \u2194 (f a \u2208 s)\n", "mem_Inter : x \u2208 (\u22c2 i, s i) \u2194 \u2200 i, x \u2208 s i\n", "\n# Level 3: The preimage of an intersection\n\nTo complete this level you will need to use the `mem_preimage` and `mem_Inter`\ntheorems, which you can find in the side bar.\n\n", "If f is a function and A_i are sets, then f\u207b\u00b9(\u22c2 A_i)=\u22c2 f\u207b\u00b9(A_i)\n", "Basic definitions", "import basic_defs_world.definition -- hide\n", "univ_mem : is_open set.univ\n", "inter : \u2200 (U V : set X) (hA : is_open U) (hB : is_open V), is_open (U \u2229 V)\n", "union : \u2200 (Y : set (set X)) (h : \u2200 U \u2208 Y, is_open U), is_open (\u22c3\u2080 Y)\n", "sUnion_empty : \u22c3\u2080 \u2205 = \u2205\n", "# Level 1 : The empty set is open.\n", "noncomputable theory -- hide\n", "open set -- hide\n", "In many textbooks, one of the axioms of a topological space is that the empty set is open. This actually follows from the other axioms!\n", "namespace topological_space -- hide\n", "In Lean, sets are notation for logical statements. That is, the set\n`a \u2208 { x : X | P x }` means *the same as* `P a`. As a somewhat degenerate\nexample, `a \u2208 \u2205` means `false`.\n", "Click here for a hint, in case you get stuck.", "Prove that the empty set is open.\n", "end topological_space -- hide\n", "import basic_defs_world.level1 --hide\n", "open set --hide\n", "namespace topological_space --hide\n", "# Level 2: Union of two open sets\n", "The union of two open sets is open.\n", "end topological_space --hide\n", "import basic_defs_world.level2 --hide\n", "import set_theory_world.level11 --hide\n", "open set --hide\n", "namespace topological_space --hide\n", "# Level 3: Intersection of a finite set of open sets is open.\n", "The `sInter_of_inter` lemma will be of great help here.\n", "Click here for a hint, in case you get stuck.", "The intersection of a finite set of open sets is open.\n", "end topological_space --hide\n", "Interior world", "import basic_defs_world.level1 -- hide\n", "is_neighborhood : \u2203 U, is_open U \u2227 x \u2208 U \u2227 U \u2286 A\n", "is_interior_point : is_neighborhood x A\n", "interior := { x : X | is_interior_point x A }\n", "In this world we will end up having three alternative definitions of the interior of a set. \nThis will be very useful, because at any point we will be able to choose the one that better fits our needs.\n\nFirst of all we need to figure out what properties does the interior of an arbitrary set have... So we start with an easy one:\n\n# Level 1: The interior is contained in the original set\n\n", "variables {X : Type} -- hide\n", "variables [topological_space X] (x : X)  (A : set X) -- hide\n", "namespace topological_space -- hide\n", "@[simp]  -- hide\n", "The interior of any set A is contained in the set A.\n", "end topological_space -- hide\n", "import interior_world.level1 --hide\n", "\n# Level 2: Second definition of the interior\n\nBefore we keep proving properties of the iterior of an arbitrary set, we will prove an alternative definition of it.\n\n", "variables {X : Type} -- hide\n", "variables [topological_space X] (x : X)  (A : set X) -- hide\n", "namespace topological_space -- hide\n", "The interior of a set A is the union of all the open sets that it contains:\n$ \\operatorname{int}(A) = \\bigcup_{U \\subseteq A, U\\text{ open}} U$\n", "end topological_space -- hide\n", "import interior_world.level2 --hide\n", "\n# Level 3: The interior is open\n\n\n\n", "variables {X : Type} -- hide\n", "variables [topological_space X] (x : X)  (A : set X) -- hide\n", "namespace topological_space -- hide\n", "The interior of a set is open.\n", "end topological_space -- hide\n", "import interior_world.level3 --hide\n", "\n# Level 4: The interior is the maximal open subset\n\n\n\n", "variables {X : Type} -- hide\n", "variables [topological_space X] (x : X)  (A : set X) -- hide\n", "namespace topological_space -- hide\n", "If B is an open set contained in A, then B is contained in the interior of A.\n", "end topological_space -- hide\n", "import interior_world.level4 --hide\n", "\n# Level 5: Characterization of the interior\n\n\n\n", "variables {X : Type} -- hide\n", "variables [topological_space X] (x : X)  (A B : set X) -- hide\n", "namespace topological_space -- hide\n", "The interior of a set A is the biggest subset satisfying:\n - It is contained in A\n - It is open.\n", "end topological_space -- hide\n", "Separation world", "import basic_defs_world.level1 -- hide\n", "t0 : \u2200 (x y : X) (h : y \u2260 x) , \u2203 (U : set X) (hU : is_open U), ((x \u2208 U) \u2227 (y \u2209 U)) \u2228 ((x \u2209 U) \u2227 (y \u2208 U))\n", "t1 : \u2200 (x y : X) (h : y \u2260 x), \u2203 (U : set X) (hU : is_open U), (x \u2208 U) \u2227 (y \u2209 U)\n", "\n# Level 1: Every Frechet space is a T\u2080 space\n\n", "variables {X : Type} -- hide\n", "variables [topological_space X] -- hide\n", "namespace topological_space -- hide\n", "Let \u03c4 be a topological space. If \u03c4 is a frechet space is also a T\u2080.\n", "end topological_space -- hide\n", "import separation_world.level1 -- hide\n", "# Level 2: Comparison between the definition given and common definition of T\u2081\n", "variables {X : Type} -- hide\n", "variables [topological_space X] -- hide\n", "namespace topological_space -- hide\n", "The definitions T1_space and T1_space' are equivalent.\n", "end topological_space -- hide\n", "import separation_world.level2 -- hide\n", "# Level 3: Lemma about intersection of open sets\n", "variables {X : Type} -- hide\n", "variables [topological_space X] -- hide\n", "namespace topological_space -- hide\n", "open set -- hide\n", "Let \u03c4 be a topological space. \u03c4 is a frechet space if only if for all the points in the topology, their singletons are closed sets.\n", "end topological_space -- hide\n", "import separation_world.level3 -- hide\n", "# Level 4: Characterisation of Frechet spaces\n", "variables {X : Type} -- hide\n", "variables [topological_space X] -- hide\n", "namespace topological_space -- hide\n", "open set -- hide\n", "Let \u03c4 be a topological space. \u03c4 is a frechet space if only if for all the points in the topology, their singletons are closed sets.\n", "end topological_space -- hide\n", "import separation_world.level4 -- hide\n", "# Level 5: Every T\u2082 space is also T\u2081\n", "variables {X : Type} -- hide\n", "variables [topological_space X] -- hide\n", "namespace topological_space -- hide\n", "open set -- hide\n", "Let \u03c4 be a topological space. \u03c4 is a frechet space if only if for all the points in the topology, their singletons are closed sets.\n", "end topological_space -- hide\n", "import separation_world.level5 -- hide\n", "# Level 6: Characterisation of Frechet spaces\n", "variables {X : Type} -- hide\n", "variables [topological_space X] -- hide\n", "namespace topological_space -- hide\n", "open set -- hide\n", "Let \u03c4 be a topological space. \u03c4 is a frechet space if only if for all the points in the topology, their singletons are closed sets.\n", "end topological_space -- hide\n", "Filter world", "import filter_world.definition --hide\n", "open set --hide\n", "namespace filters --hide\n", "# Level 1: The principal filter of a subset\n", "def principal' {X : Type} (s : set X) := {t | s \u2286 t}\n", "The collection of subsets defined before have a filter structure.\n", "localized \"notation `P` := principal\" in filters -- hide\n", "end filters --hide\n", "import filter_world.level1 --hide\n", "open set --hide\n", "namespace filters --hide\n", "localized \"notation `P` := principal\" in filters --hide\n", "lemma mem_principal {X : Type} {s t : set X} : s \u2208 P t \u2194 t \u2286 s := iff.rfl -- hide\n", "mem_principal : s \u2208 P t \u2194 t \u2286 s\n", "# Level 2: Characterization of the princial filter of the total set\n", "The only element of the principal filter of the universal set is the universal set.\n", "end filters --hide\n", "import filter_world.level2 --hide\n", "open set --hide\n", "namespace filters --hide\n", "localized \"notation `P` := principal\" in filters --hide\n", "# Level 3: The bottom filter\n", "There exists a bottom filter among the filters of a given set.\n", "end filters --hide\n", "import filter_world.level3 --hide\n", "open set --hide\n", "namespace filters --hide\n", "localized \"notation `P` := principal\" in filters --hide\n", "# Level 4: The meet of a pair of filters\n", "def meet_set' {X : Type*} (V F : filter X) := {t | \u2203 (v \u2208 V) (f \u2208 F), v \u2229 f \u2286 t}\n", "The collection of subsets defined before is a filter.\n", "def meet {\u03b1 : Type*} (V F : filter \u03b1) : filter \u03b1 := --hide\n", "{ sets := {t | \u2203 (v f : set \u03b1), v \u2208 V \u2227 f \u2208 F \u2227 v \u2229 f \u2286 t }, --hide\n", "  univ_sets := \u27e8univ, univ, V.univ_sets, F.univ_sets, (univ \u2229 univ).subset_univ\u27e9, --hide\n", "  sets_of_superset := (\u03bb A B \u27e8v, f, hv, hf, H\u27e9 hAB, \u27e8v, f, hv, hf, subset.trans H hAB\u27e9), --hide\n", "  inter_sets := --hide\n", "  begin --hide\n", "    rintros A B \u27e8v\u2081, f\u2081, hv\u2081, hf\u2081, H\u2081\u27e9 \u27e8v\u2082, f\u2082, hv\u2082, hf\u2082, H\u2082\u27e9, --hide\n", "    have : v\u2081 \u2229 v\u2082 \u2229 (f\u2081 \u2229 f\u2082) = v\u2081 \u2229 f\u2081 \u2229 (v\u2082 \u2229 f\u2082), --hide\n", "      by rwa [\u2190 inter_assoc, inter_assoc v\u2081, inter_comm v\u2082, \u2190 inter_assoc, \u2190 inter_assoc], --hide\n", "    obtain hvf := inter_subset_inter H\u2081 H\u2082, --hide\n", "    exact \u27e8v\u2081 \u2229 v\u2082, f\u2081 \u2229 f\u2082, V.inter_sets hv\u2081 hv\u2082, F.inter_sets hf\u2081 hf\u2082, by rwa this\u27e9 --hide\n", "  end } --hide\n", "end filters --hide", "import filter_world.level4 --hide\n", "open set --hide\n", "namespace filters --hide\n", "localized \"notation `P` := principal\" in filters --hide\n", "# Level 5: The meet filter of two filters, greates lower bound\n", "The meet of two filters is their greatest lower bound. \n", "end filters --hide", "Open and closed world", "import interior_world.level5 --hide\n", "\n# Level 2: Second definition of the interior\n\nBefore we keep proving properties of the iterior of an arbitrary set, we will prove an alternative definition of it.\n\n", "variables {X : Type} -- hide\n", "variables [topological_space X] (x : X)  (A : set X) -- hide\n", "open set --hide\n", "namespace topological_space -- hide\n", "The interior of a set A is the union of all the open sets that it contains:\n$ \\operatorname{int}(A) = \\bigcup_{U \\subseteq A, U\\text{ open}} U$\n", "end topological_space -- hide\n"]]}